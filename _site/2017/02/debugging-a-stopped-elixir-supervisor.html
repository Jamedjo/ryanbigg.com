<!DOCTYPE HTML>
<html>
  <head>
    <title>Ryan Bigg - Debugging a stopped Elixir Supervisor</title>
    <link href="http://feeds.feedburner.com/ryanbigg" rel="alternate" title="The Life of a Radar" type="application/atom+xml" />
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Titillium+Web" rel="stylesheet">
    <link rel='stylesheet' href='/css/style.css' media='screen'>
    <link rel='stylesheet' href='/css/mobile.css'>
    <link rel='stylesheet' href='/css/prism.css'>
    <script src='/js/prism.js'></script>

  <body>
    <h1 align='center'><a href='http://ryanbigg.com'>Ryan Bigg</a></h1>
    <div id='post'>
      <article>
        <a href="/2017/02/debugging-a-stopped-elixir-supervisor"><h2>Debugging a stopped Elixir Supervisor</h2></a>
        <small>23 Feb 2017</small><br>
        <p>We&#39;ve been doing a lot of work with Elixir at <a href="https://www.cultureamp.com/">Culture Amp</a>, building out several microservices in it and we&#39;re also using event sourcing to pass events from our Rails monolith (called &quot;Murmur&quot;) out to these services. In order to pass these events out to the services, we built a microservice called Event Hub.</p>

<p>Event Hub was built to receive events from Murmur and then to provide streams for these events that our other microservices could then read from. Writing the events directly to the microservices would mean that we would need to keep a list of microservices to write to and update that if we added in any new service. By writing the events to the Event Hub instead, we could have multiple microservices consuming the same streams from the Event Hub without issue. It&#39;s up to each microservice to keep track of what event it has currently read up to in the stream.</p>

<p>However, we ran into an issue a ways into our implementation when we wanted to take a point-in-time snapshot of our databases. Attempting to take a snapshot of a Mongo database (Murmur) and a PostgreSQL database (Event Hub) at the same point in time proved to be too difficult. So we changed tactics and ended up writing events directly Murmur&#39;s Mongo database. This way, we can choose to backup Murmur&#39;s Mongo database and the microservices independently from each other. If we restore a microservice from backup and it&#39;s behind in its events, we can catch it up by reading those events from a restored Event Hub.</p>

<p>We then needed a way to get events from Murmur&#39;s Mongo database into Event Hub, as we wanted Event Hub to be able to work separately from Murmur. If Murmur goes down, we don&#39;t want it to affect Event Hub and vice versa. For this transferral of events we built another microservice: Copy Cat.</p>

<h2>Copy Cat</h2>

<p>Copy Cat worked by using the master branch of <a href="https://github.com/michalmuskala/mongodb_ecto">mongodb_ecto</a> to read events from Murmur&#39;s Mongo database, and then it used <a href="http://hex.pm/packages/ecto">Ecto</a> to write these events to Event Hub&#39;s PostgreSQL database.</p>

<p>Copy Cat was setup with a supervision tree which looks like this:</p>

<p><center>
  <img src="/images/copycat/supervision.png" alt="Supervision tree">
</center></p>

<p>Code-wise, here&#39;s what it looks like. Let&#39;s start with <code>lib/copy_cat.ex</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">def</span> <span class="n">start</span><span class="p">(</span><span class="n">_type</span><span class="p">,</span> <span class="n">_args</span><span class="p">)</span> <span class="k">do</span>
  <span class="kn">import</span> <span class="no">Supervisor</span><span class="o">.</span><span class="no">Spec</span>

  <span class="n">children</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">supervisor</span><span class="p">(</span><span class="no">CopyCat</span><span class="o">.</span><span class="no">Murmur</span><span class="o">.</span><span class="no">Repo</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="n">supervisor</span><span class="p">(</span><span class="no">CopyCat</span><span class="o">.</span><span class="no">EventHub</span><span class="o">.</span><span class="no">Repo</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="n">supervisor</span><span class="p">(</span><span class="no">CopyCat</span><span class="o">.</span><span class="no">ImportSupervisor</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="n">router</span><span class="p">,</span>
  <span class="p">]</span>

  <span class="n">opts</span> <span class="o">=</span> <span class="p">[</span><span class="ss">strategy:</span> <span class="ss">:one_for_one</span><span class="p">,</span> <span class="ss">name:</span> <span class="no">CopyCat</span><span class="o">.</span><span class="no">Supervisor</span><span class="p">]</span>
  <span class="no">Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>And then <code>lib/copy_cat/import_supervisor.ex</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defmodule</span> <span class="no">CopyCat</span><span class="o">.</span><span class="no">ImportSupervisor</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Supervisor</span>

  <span class="k">def</span> <span class="n">start_link</span> <span class="k">do</span>
    <span class="no">Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">[],</span> <span class="ss">name:</span> <span class="no">CopyCat</span><span class="o">.</span><span class="no">ImportSupervisor</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">init</span><span class="p">([])</span> <span class="k">do</span>
    <span class="n">child_options</span>
    <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="p">(</span><span class="no">CopyCat</span><span class="o">.</span><span class="no">EventImporter</span><span class="p">,</span> <span class="p">[</span><span class="nv">&amp;1</span><span class="p">],</span> <span class="ss">id:</span> <span class="n">make_ref</span><span class="p">))</span>
    <span class="o">|&gt;</span> <span class="n">supervise</span><span class="p">(</span><span class="ss">strategy:</span> <span class="ss">:one_for_one</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">defp</span> <span class="n">child_options</span> <span class="k">do</span>
    <span class="p">[</span>
      <span class="p">[</span>
        <span class="ss">source:</span>      <span class="no">CopyCat</span><span class="o">.</span><span class="no">Murmur</span><span class="o">.</span><span class="no">SurveyEvent</span><span class="p">,</span>
        <span class="ss">destination:</span> <span class="no">CopyCat</span><span class="o">.</span><span class="no">EventHub</span><span class="o">.</span><span class="no">SurveyEvent</span><span class="p">,</span>
        <span class="ss">name:</span>        <span class="no">CopyCat</span><span class="o">.</span><span class="no">SurveyImporter</span><span class="p">,</span>
      <span class="p">],</span>
      <span class="p">[</span>
        <span class="ss">source:</span>      <span class="no">CopyCat</span><span class="o">.</span><span class="no">Murmur</span><span class="o">.</span><span class="no">InvitationEvent</span><span class="p">,</span>
        <span class="ss">destination:</span> <span class="no">CopyCat</span><span class="o">.</span><span class="no">EventHub</span><span class="o">.</span><span class="no">InvitationEvent</span><span class="p">,</span>
        <span class="ss">name:</span>        <span class="no">CopyCat</span><span class="o">.</span><span class="no">InvitationImporter</span><span class="p">,</span>
      <span class="p">],</span>
      <span class="o">...</span>
    <span class="p">]</span>
  <span class="k">end</span>
</code></pre></div>
<p>We designed the supervision tree this way so that if one event importer process crashed it wouldn&#39;t take down any of the others. We have also designed the events so that they can be imported into this system completely independently from any other event.</p>

<p>Each event importer process works off a unique stream. If that event impoter process crashes, then it will be restarted automatically because of it living underneath <code>CopyCat.ImportSupervisor</code>. This supervisor has the default <code>max_restarts</code> and <code>max_seconds</code> values of 3 and 5 respectively, which means that if there are 3 process restarts within the space of 5 seconds then this will cause the <code>CopyCat.ImportSupervisor</code> to be restarted too.</p>

<p>Because <code>CopyCat.ImportSupervisor</code> is supervised in turn by <code>CopyCat.Supervisor</code>, the same rule applies: if <code>CopyCat.ImportSupervisor</code> restarts 3 times within 5 seconds then the application will die.</p>

<p>Shortly after we deployed Copy Cat to our production environment (near the end of January), we observed issues where the importing of events would just stop suddenly. Nothing was output to the log file, which is what we expected to happen if one of the <code>EventImporter</code> workers encountered an exception. It was almost as if all the workers were waiting for <em>something</em> to happen, but we didn&#39;t have any information on what that might&#39;ve been. A few days later, this issue happened on our staging server and a developer&#39;s Mac.</p>

<p>None of us could figure it out at all, with most of us having less than a year&#39;s worth of using-Elixir-in-production experience. This issue continued for almost a month with nobody being able to figure it out.</p>

<h2>Splunk alerting to the rescue (temporarily)</h2>

<p>The application was still running and responding to heartbeat checks -- each of our microservices has a <code>/status</code> endpoint -- but it appeared that the workers had stopped running completely. We&#39;d notice the workers stopped working because their status messages -- messages that look like this:</p>
<div class="highlight"><pre><code class="language-" data-lang="">13:42:10.155 [info] Fetched 0 CopyCat.Murmur.SurveyEvent from Murmur
</code></pre></div>
<p>Would stop being printed to our Splunk logs. We were able to setup an alert in Splunk that would notify us if there were none of these messages after a few minutes, however this was only ever intended as a stop-gap to tracking down the issue.</p>

<p>This alert was posted into our Slack channel whenever it happened, and it typically happened every few days. When we saw the alert, we would just restart the service. Everything would come back up and Copy Cat would keep processing events as if nothing happened.</p>

<h2>The &quot;Baby Monitor&quot;</h2>

<p>Jo, our team lead, thought that this issue may be happening because the worker processes were somehow crashing silently. I admit, I thought this idea was silly! Worker processes don&#39;t <em>crash silently</em> in Elixir!</p>

<p>She came up with an idea that we should have <em>another</em> endpoint which returned the number of worker processes that were currently running underneath the <code>CopyCat.ImportSupervisor</code>. We called this endpoint the &quot;baby monitor&quot;. The code for that endpoint is fairly simple:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">get</span> <span class="sd">"</span><span class="s2">/importers"</span> <span class="k">do</span>
  <span class="n">importers</span> <span class="o">=</span> <span class="no">CopyCat</span><span class="o">.</span><span class="no">ImportSupervisor</span> <span class="o">|&gt;</span> <span class="no">Supervisor</span><span class="o">.</span><span class="n">which_children</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">count</span>
  <span class="n">conn</span>
  <span class="o">|&gt;</span> <span class="n">put_resp_content_type</span><span class="p">(</span><span class="sd">"</span><span class="s2">application/json"</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="n">send_resp</span><span class="p">(</span><span class="ss">:ok</span><span class="p">,</span> <span class="err">~</span><span class="n">s</span><span class="p">({</span> <span class="sd">"</span><span class="s2">running_importers"</span><span class="p">:</span> <span class="c1">#{importers} }))</span>
<span class="k">end</span>
</code></pre></div>
<p>This uses <code>Supervisor.which_children/1</code> to gather up all the child processes of <code>CopyCat.ImportSupervisor</code> and then <code>Enum.count/1</code> to count them up. This endpoint should then return the number of event importers that we were expecting: 5. I wrote this code thinking that it wasn&#39;t going to be much help in diagnosing the issue and boy was I wrong.</p>

<p>When the importing stopped again, we hit this endpoint to see how many workers were running and we didn&#39;t get the kind of number back that we were expecting: We got a &quot;500 Internal Server Error&quot; response instead. We looked at our logs, and saw something like this:</p>
<div class="highlight"><pre><code class="language-" data-lang="">15:56:46.523 [error] #PID&lt;0.490.0&gt; running CopyCat.Router terminated
Server: localhost:4600 (http)
Request: GET /importers
** (exit) exited in: GenServer.call(CopyCat.ImportSupervisor, :which_children, :infinity)
    ** (EXIT) no process
</code></pre></div>
<p>When you use <code>Supervisor.which_children/1</code>, it makes a call using <code>GenServer.call/3</code> to the process you&#39;ve asked for, as we can see by the first <code>(exit)</code> line here. The <em>second, shoutier</em> <code>(EXIT)</code> line tells us &quot;no process&quot;. Huh? How can the <code>CopyCat.ImportSupervisor</code> not exist? If that were to happen, then <code>CopyCat.Supervisor</code> should&#39;ve died as well. What was going on?</p>

<h2>Transient Restart</h2>

<p>Concurrently to our investigation of this issue, work continued on Copy Cat. One piece of work that was done by Jo involved us making it possible to shut down <code>CopyCat.ImportSupervisor</code> for a time, clear out Event Hub&#39;s database and then to start up <code>CopyCat.ImportSupervisor</code> again. We needed this feature for staging environment testing purposes.</p>

<p>To make this possible, we added the <code>restart: :transient</code> option to <code>CopyCat.ImportSupervisor</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">def</span> <span class="n">start</span><span class="p">(</span><span class="n">_type</span><span class="p">,</span> <span class="n">_args</span><span class="p">)</span> <span class="k">do</span>
  <span class="kn">import</span> <span class="no">Supervisor</span><span class="o">.</span><span class="no">Spec</span>

  <span class="n">children</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">supervisor</span><span class="p">(</span><span class="no">CopyCat</span><span class="o">.</span><span class="no">Murmur</span><span class="o">.</span><span class="no">Repo</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="n">supervisor</span><span class="p">(</span><span class="no">CopyCat</span><span class="o">.</span><span class="no">EventHub</span><span class="o">.</span><span class="no">Repo</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="n">supervisor</span><span class="p">(</span><span class="no">CopyCat</span><span class="o">.</span><span class="no">ImportSupervisor</span><span class="p">,</span> <span class="p">[</span><span class="ss">restart:</span> <span class="ss">:transient</span><span class="p">]),</span>
    <span class="n">router</span><span class="p">,</span>
  <span class="p">]</span>

  <span class="n">opts</span> <span class="o">=</span> <span class="p">[</span><span class="ss">strategy:</span> <span class="ss">:one_for_one</span><span class="p">,</span> <span class="ss">name:</span> <span class="no">CopyCat</span><span class="o">.</span><span class="no">Supervisor</span><span class="p">]</span>
  <span class="no">Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>This allows us to stop <code>CopyCat.ImportSupervisor</code> by calling these functions:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="no">Supervisor</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="no">CopyCat</span><span class="o">.</span><span class="no">ImportSupervisor</span><span class="p">)</span>
<span class="no">Supervisor</span><span class="o">.</span><span class="n">delete_child</span><span class="p">(</span><span class="no">CopyCat</span><span class="o">.</span><span class="no">Supervisor</span><span class="p">,</span> <span class="no">CopyCat</span><span class="o">.</span><span class="no">ImportSupervisor</span><span class="p">)</span>
</code></pre></div>
<p>The <code>CopyCat.ImportSupervisor</code> won&#39;t be resurrected by <code>CopyCat.Supervisor</code> in this instance because its <code>restart</code> option is now set to <code>:transient</code>. This means it&#39;s up to us to maintain whether <code>CopyCat.ImportSupervisor</code> is up or not.</p>

<p>After this work was done, the bug happened again. Initially, we thought it was because our endpoint to stop the <code>CopyCat.ImportSupervisor</code> was called, but we didn&#39;t see any evidence of that. It was being stopped by something else, but we didn&#39;t have any indication as to what to go on.</p>

<aside>
I should also mention at this point that CopyCat.ImportSupervisor certainly exhibited this "silent crashing" behaviour <em>before</em> the transient restart code was added. Attempts to reproduce the bug without having CopyCat.ImportSupervisor in the "transient restart" mode so far have been unsuccessful.
</aside>

<p>I looked up on Elixir&#39;s GitHub issues the phrase &quot;supervisor stop&quot; hoping that someone else had come across a similar issue and it turned up <a href="https://github.com/elixir-lang/elixir/issues/2432">this completely unrelated issue</a> which mentions using <a href="http://erlang.org/doc/man/dbg.html"><code>:dbg</code></a> to investigate messages being sent through Erlang. This looked like exactly what I wanted: a way to see what was sending a message to the <code>CopyCat.ImportSupervisor</code> process telling it to shut down.</p>

<h2>dbg to the rescue</h2>

<p>So off I went and added <code>:dbg</code> to the application. I did that by changing <code>CopyCat.ImportSupervisor.start_link</code> to this:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">def</span> <span class="n">start_link</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="o">=</span> <span class="no">Supervisor</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">[],</span> <span class="ss">name:</span> <span class="no">CopyCat</span><span class="o">.</span><span class="no">ImportSupervisor</span><span class="p">)</span>
  <span class="c1"># TEMPORARY! Used to figure out why CopyCat.ImportSupervisor is crashing</span>
  <span class="c1"># Starts the dbg tracer</span>
  <span class="c1"># Read all about it: http://erlang.org/doc/man/dbg.html</span>
  <span class="ss">:dbg</span><span class="o">.</span><span class="n">tracer</span>
  <span class="c1"># Monitor the pid, and log out all messages that this PID receives</span>
  <span class="c1"># If this process is being told to shutdown, this will output</span>
  <span class="ss">:dbg</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">[</span><span class="ss">:all</span><span class="p">])</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div>
<p>As the comments say, this sets up <code>dbg</code> tracer and then monitors all the messages sent or received by the process.</p>

<p>I then got this change code reviewed + deployed to our staging server. Then I had to wait for this bug to happen again. Luckily, it happened again the very next day. This time, we had some logs from dbg:</p>
<div class="highlight"><pre><code class="language-" data-lang=""> (&lt;0.404.0&gt;) &lt;&lt; {'EXIT',&lt;0.409.0&gt;,
  {timeout,
      {'Elixir.GenServer',call,
          [&lt;0.213.0&gt;,
           {update,&lt;&lt;"comment_topic_events"&gt;&gt;,
               [{'_id',
                    #{'__struct__' =&gt; 'Elixir.BSON.ObjectId',
                      value =&gt; &lt;&lt;88,142,206,90,219,77,8,62,134,0,75,
                        108&gt;&gt;}}],
               [{'$set',[{status,&lt;&lt;"propagated"&gt;&gt;}]}],
               [{multi,false}]},
           5000]}}} (Timestamp: {1487,736694,937453})
</code></pre></div>
<p>Aha! A timeout in our queries. This seemed to be the cause of our issues. There were a few more timeouts like this for some of the <code>CopyCat.EventImporter</code> workers, and because they all crashed so close together, this happened:</p>
<div class="highlight"><pre><code class="language-" data-lang="">(&lt;0.404.0&gt;) error_logger ! {notify,
  {error_report,&lt;0.196.0&gt;,
   {&lt;0.404.0&gt;,supervisor_report,
    [{supervisor,
      {local,'Elixir.CopyCat.ImportSupervisor'}},
     {errorContext,shutdown},
     {reason,reached_max_restart_intensity},
     {offender,
      [{pid,&lt;0.466.0&gt;},
       {id,#Ref&lt;0.0.1.110489&gt;},
       {mfargs,
        {'Elixir.CopyCat.EventImporter',start_link,
         [[{source,
            'Elixir.CopyCat.Murmur.ResponseEvent'},
           {destination,
            'Elixir.CopyCat.EventHub.ResponseEvent'},
           {name,
            'Elixir.CopyCat.ResponseImporter'}]]}},
</code></pre></div>
<p>This indicates that <code>CopyCat.ImportSupervisor</code> has reached its &quot;max restart intensity&quot; and is about to shut down. This also gives us some information that it&#39;s the <code>ResponseImporter</code> worker which struck the final blow here. A little bit further down then we see the <code>CopyCat.ImportSupervisor</code> is unregistered:</p>
<div class="highlight"><pre><code class="language-" data-lang=""> (&lt;0.404.0&gt;) unregister 'Elixir.CopyCat.ImportSupervisor' ...
</code></pre></div>
<p>Because this supervisor is &quot;transient&quot;, it&#39;s allowed to go down in a &quot;normal&quot; shutdown without being resurrected by <code>CopyCat.Supervisor</code>. If the workers were raising exceptions, then <code>CopyCat.ImportSupervisor</code> would restart them until it reached the &quot;max restart intensity&quot;, and then <code>CopyCat.ImportSupervisor</code> would die. <code>CopyCat.Supervisor</code> would then restart <code>CopyCat.ImportSupervisor</code>. But the workers <em>weren&#39;t</em> raising exceptions, even though a query timing out is something that I&#39;d consider to be <em>exceptional</em>.</p>

<h2>SASL</h2>

<p>I asked about this issue on the #elixir-lang channel on Freenode and I was told by <a href="https://github.com/michalmuskala">micmus</a> about the <a href="http://erlang.org/doc/man/sasl_app.html"><code>:sasl</code> application</a>.</p>

<p>Just by adding this application to the <code>applications</code> list in <code>mix.exs</code>, I was told that I&#39;d be able to get information about the processes being started / stopped as well. Here&#39;s the change I made:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">def</span> <span class="n">application</span> <span class="k">do</span>
  <span class="p">[</span><span class="ss">applications:</span> <span class="p">[</span><span class="ss">:logger</span><span class="p">,</span> <span class="ss">:poolboy</span><span class="p">,</span> <span class="ss">:sasl</span><span class="p">],</span>
   <span class="ss">mod:</span> <span class="p">{</span><span class="no">CopyCat</span><span class="p">,</span> <span class="p">[]}]</span>
<span class="k">end</span>
</code></pre></div>
<p>By starting the <code>:sasl</code> application, I could then get some info regarding the processes. Here&#39;s an example from my <a href="https://github.com/radar/copy_lion">copy_lion</a> repo which was my attempt to reproduce this timeout issue in a succinct way:</p>
<div class="highlight"><pre><code class="language-" data-lang="">=SUPERVISOR REPORT==== 23-Feb-2017::16:35:38 ===
     Supervisor: {local,'Elixir.CopyLion.ImportSupervisor'}
     Context:    child_terminated
     Reason:     {timeout,
                     {'Elixir.GenServer',call,
                         [&lt;0.202.0&gt;,
                          {find,&lt;&lt;"response_events"&gt;&gt;,
                              #{&lt;&lt;"$where"&gt;&gt; =&gt; &lt;&lt;"sleep(5000)"&gt;&gt;},
                              nil,
                              [{batch_size,1000}]},
                          5000]}}
     Offender:   [{pid,&lt;0.217.0&gt;},
                  {id,#Ref&lt;0.0.4.272&gt;},
                  {mfargs,
                      {'Elixir.CopyLion.EventImporter',start_link,
                          [[{name,'Elixir.CopyCat.SurveyImporter'}]]}},
                  {restart_type,permanent},
                  {shutdown,5000},
                  {child_type,worker}]
</code></pre></div>
<p>The <code>copy_lion</code> application will on-purpose cause a query to take longer than 5 seconds, and so we get the same kind of &quot;timeout&quot; exit that&#39;s happen here too. When this happens, <code>CopyLion.ImportSupervisor</code> restarts <code>CopyLion.EventImporter</code> processes. However, when <code>CopyLion.ImportSupervisor</code> is changed to use <code>restart: :transient</code> then <code>CopyLion.ImportSupervisor</code> doesn&#39;t get restarted and we see the same kind of behaviour we were seeing only intermittently before.</p>

<p>If the timeouts here were raising exceptions, it would be a different story. The <code>CopyCat.ImportSupervisor</code> would receive exceptions from its children and then -- with enough of them -- would restart itself. Since these timeouts are not exceptional, the <code>CopyCat.ImportSupervisor</code> is not restarted automatically by <code>CopyCat.Supervisor</code>.</p>

<p>The best part about using the <code>:sasl</code> application here is that we&#39;re now getting valuable logs of what&#39;s happening with our supervisors and the processes they monitor, whereas before we didn&#39;t have a single line of information to go on.</p>

<h2>The fix</h2>

<p>During our investigation of this issue we found out about the <a href="https://github.com/michalmuskala/mongodb_ecto/tree/ecto-2"><code>ecto-2</code> branch of mongodb_ecto</a>. This branch upgrades the version of Ecto and, most importantly, the version of the <a href="https://github.com/ericmj/mongodb">mongodb package</a> that is used.</p>

<p>I used this new version of the <code>mongodb</code> package on <code>copy_lion</code> (which you can see on <a href="https://github.com/radar/copy_lion/tree/mongo-0.2.0">my <code>mongo-0.2.0</code> branch</a>) and I saw that when the query timed out an exception was actually raised:</p>
<div class="highlight"><pre><code class="language-" data-lang="">16:41:58.235 [error] Mongo.Protocol (#PID&lt;0.630.0&gt;) disconnected: ** (DBConnection.ConnectionError) client #PID&lt;0.619.0&gt; timed out because it checked out the connection for longer than 5000ms

16:41:58.237 [error] Process #PID&lt;0.619.0&gt; raised an exception
** (Mongo.Error) tcp recv: unknown POSIX error - :timeout
    (mongodb) lib/mongo/cursor.ex:40: anonymous fn/6 in Enumerable.Mongo.Cursor.start_fun/6
    (elixir) lib/stream.ex:1121: anonymous fn/5 in Stream.resource/3
    (elixir) lib/enum.ex:1627: Enum.reduce/3
    (elixir) lib/enum.ex:2346: Enum.to_list/1
</code></pre></div>
<p>This gives me a large amount of confidence that the latest version of the <code>mongodb</code> package will no longer cause <code>CopyCat.ImportSupervisor</code> to exit normally, but will instead raise exceptions when a timeout is encountered. When this happens, <code>CopyCat.ImportSupervisor</code> will exit with an exception too, causing <code>CopyCat.Supervisor</code> to restart it.</p>

<p>I&#39;ve now got a pull request in the works for Copy Cat to use this <code>ecto-2</code> branch, but that only means that an exception will now be raised when a timeout is encountered. It doesn&#39;t make the timeout go away.</p>

<p>Luckily, Sushma -- who&#39;s another developer on our team -- was able to track down one query that was performing slowly and applied a fix for it:</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff">     source_module
     |&gt; Queries.published_after(published_at(last))
<span class="gi">+    |&gt; Queries.propagated
</span>     |&gt; MurmurRepo.update_all(set: [status: "created"])
   end
</code></pre></div>
<p>Prior to this change, the query wasn&#39;t using the indexes that we had setup for our events tables. I suspect that this first update query taking a long time on the events collection meant that the collection was locked for further writing. Subsequent updates to the collection were blocked until this first query finished, which was the root cause for our timeouts.</p>

<h2>Conclusion</h2>

<p>Ultimately, we need to do better work on profiling slow queries within our Mongo database. If we were somehow notified of slow queries before we were notified of Copy Cat&#39;s issues, then we may have discovered the root cause of this issue sooner. That&#39;s something we&#39;ll be looking at doing in the future.</p>

<p>Switching to the <code>ecto-2</code> branch, while risky due to its in-progress state, seemingly fixes our issue of having Copy Cat mysteriously stop. What will happen now if a timeout happens is that there&#39;ll be an exception raised. This is much easier to handle because with that exception we&#39;ll have some information about what queries are slow.</p>

<p>Elixir and Erlang do give you some very powerful tools that you can use to diagnose what your application is doing at any given moment. If you&#39;re seeing your Elixir application behaving weirdly, I&#39;d recommend using <code>:sasl</code> and <code>:dbg</code> to figure out what&#39;s going on.</p>

      </article>
    </div>
    <div id='disqus_thread'></div>
    <script type="text/javascript">
        var disqus_shortname = 'ryanbigg'; // required: replace example with your forum shortname

        var disqus_identifier = 'RB-376 http://ryanbigg.com/?p=RB-376'
        var disqus_url = 'http://ryanbigg.com/2017/02/debugging-a-stopped-elixir-supervisor';
    </script>
    <script src='http://ryanbigg.disqus.com/embed.js'></script>

    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-60556315-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
