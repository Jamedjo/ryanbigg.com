I have seen the future.

Five years from now, someone will get on a stage like this one (or perhaps
even this one) and _blow your freaking minds_. This person will _astound_ you
with a radical talk on a subject we, in the present, can only guess at. That
person is not going to be Avdi, Sandi or any of the other speakers here. It's
not even going to be me -- as much as I (and my ego) would like that.

In fact, the person who will _blow your minds_ knows a model today as someone
who would walk down a catwalk in some ostentatious outfit. They think that a
view is what you get from your 25th story apartment, or from that lookout up
in the mountains. They think that "Ruby on Rails" is a cause for concern, as
enough Rubies of significant sizes on enough Rails might derail a train. And
what a waste of good jewels!

Today, this person has just started on Chris Pine's Learn to Program. They have
invoked the `puts` method for the very first time.

Tomorrow, they will attempt the Ruby Koans. Next week, they will dabble a bit
in HTML and CSS. A few months from now, they might learn that Ruby On Rails
puts the HTML and the CSS and the Rubies together and it gives them those nice
shivers of excitement when it all Just Worksâ„¢.

And five years from now they will _blow your freaking minds_ with a talk of
astonishing brilliance, eloquently delivered with perfectly timed (and
tasteful) jokes.

And five years from now, we will know very clearly who this person is. This
is because they will be on stage, speaking. And they will have a name badge
and the badge will tell us who they are.

But right now, we couldn't pick this person out from a crowd, or even a small
gathering for that matter. In our minds, this person simultaneously does and
does not exist. We can picture who they might be, but I guarantee you: the
picture doesn't match the eventual reality.

I'm not one to give out spoilers freely, so I won't tell you who they are.
You'll just have to wait and see.

But then how did I come to know this oddly-specific thing about the future?
Well, I _could_ tell you but that would ruin the surprise. So I'm not going to
tell you.

What I can tell you is that one of you will hire this person as a junior
developer and that will be their very first job. You will kick-start the career
of someone astonishingly brilliant and it's going to be all because of what
I'm about to tell you, so pay close attention.

If there was one take away from this talk that I want to stick in your minds it
would be this: hire a junior.

"But Ryan, we only hire mids and seniors!" -- ahh the classic ActiveMantra in
the Rails community: "Hiring senior Ruby developers."

Yeah but how's that working out for you at the moment? Probably not so great.
It's well known that there are only three hard problems in computer science:
cache invalidation, naming things and hiring more senior Ruby developers. There
are probably bookmakers out there that have shorter odds on scientists finding
life on another planet than we do as a community finding a senior Rails
developer looking for a job.

We have drained the talent pool dry. And yet our obsession continues. We only
hire mids and seniors. But why do we have this obsession? Well, let's take a
look at one of the main reasons.

## Hiring seniors

One of the main reasons why we want to hire mids and seniors is because our workload
has gotten to the point where it's exceeding our capacity. Tons of companies are
hiring at the moment for this very reason. The _demand_ for work is outstripping
the _supply_ of developers.

To address this problem, we hire a new developer or rather... we try to hire a
new developer. We want a mid-to-senior developer because they have the skills
to instantly dive straight into our application with little-to-no guidance and
they can start shipping code. That old expression: "they can hit the ground
running". This is because our code is so brilliantly well-structured and
organized according to the Rails best practices. Nobody will have to upskill
on any single part of the codebase at all because we follow the Laws of
Sandi and Commandments of Avdi to the letter. There is no legacy code with their
legacy decisions, written in a hurry because we needed to ship that thing
_fast_. HA.

However: as I said before, we would have more luck finding life on a different
planet than being capable of finding an available Ruby developer.

In this current climate, it's downright impossible to hire a mid-to-senior Ruby
developer to come work for your company. What typically happens is that
developers get aggressively poached between companies. The salary and other
bonuses and other perks are off the charts. Just one example of how off the
charts it is: There was a not-so-big tech company in LA advertising for a
mid-to-senior Rails developer for a base rate of $230k, and that's US dollars so
it's about a bazillionty Australian pesos. Amazon, Google and Facebook offer
even more than this, with offers from $250k+ USD being common. To put it in
perspective: the average household income in the US is about $52,000, and so
these jobs are paying over 5x the average household income. It's just ludicrous.

Companies spend thousands of dollars on recruiters and lots of time posting to
job boards, for often very little good return. Companies spend this money to
hunt the elusive 10x Developer Rockstar Unicorns (note: term used ironically),
but the Unicorns are no longer out grazing in the sunny meadows, readily
available for capture.  They're already working somewhere else and the
conditions of where they work are extremely competitive. To keep with the
analogy: the meadows are filled with the greenest of grasses and the brightest
of rainbows. You will have a hard time luring these unicorns away.

We're out of freely available Rockstar Unicorns because they're already employed
elsewhere. Attempting to hire them is an exercise in futility. And so it's time
that we started to grow our own. It's time that we started to hire and train our
own 10x Developer Rockstar Unicorns.

But where do we find these developers? Well, for starters we need to lower our
bar for engineering talent and not be so caught up on hiring the
best-of-the-best _now_, but instead we should be investing more in people's
future potential.

Your next Rockstar Unicorn isn't within today's current top 5-10% of all
developers: they're hanging with the rest of their peers in the other part of
this totally scientific graph that I didn't make up.

There isn't an endless supply of brilliant people. This talent pool of amazingly
talented and gifted developers, as we're painfully finding out, is not
limitless. We must lower the bar for our hiring, and hire juniors.

It is very, very difficult to hire a senior developer today in Rubyland. And so
we must grow our own senior developers. This is a process that will take time.
There's no packet mix where you "just add water" and blammo you've got a senior
developer. I'm talking about _years_ of hard work. But these are _vital_ years
of hard work to ensure that this community continues to thrive and grow. This
work ensures that we have well-trained developers working at our companies. We
know they're well-trained because we train them ourselves.

## Juniors make teams better

We should not lower our hiring bar and hire juniors just because we can't find
seniors though. We should do it because in doing so it will make our teams
_better_.

"But Ryan, we have to ship things fast!!"

Ah yes, that old sacred cow of software development: shipping things _fast_. We
have to ship things _fast_ and hiring and mentoring juniors means that we take
time away from actually shipping things. Anything that hurts "shipping things
fast" is taboo. But what if I was to tell you that mentoring juniors meant that
you could make your team better _and_ ship things faster?  Weird, I know. But
hear me out.

First, I want to talk some more about this shipping things fast mumbo-jumbo.

### Gotta go fast!!

It's pretty strange that we, the people who get the computers to do the hard
thinking, can't find time to mentor a junior. We're too busy shipping things.
We'll hire a junior when we're not as busy. Oh the lies we tell ourselves.

Why are we too busy? What's the rush? If we don't deliver these five features
and fix these three bugs by Friday, is our company going to go down in flames?
Not usually. There are plenty of companies here who have been here for the
long-term now, and who will probably be here for just as long again. The busy-
ness will not change. We all know that work is neither a liquid or a solid. It
is a gas: it fills any and all available time.  The work is always present, but
the people who do the work are not going to be. People leave: they change jobs,
professions, countries and lifestyles. Or sometimes they just plain ol' die.

People leaving affects our rate of shipping. We have to hire new talent to
replace them. We have to train that new talent up. So how do we prepare for
people leaving our companies as a community to ensure the long-term viability of
what we're doing?

Other professions, like lawyers, mechanics, teachers and plenty of others
recognise that the people who are doing the work today aren't going to be doing
the work forever. Their work too is always ongoing and they have to do whatever
their equivalent of "shipping things fast" is.

The major difference is that these professions have active apprenticeship
efforts, where these apprentices then usually go on to become the next
generation of lawyers, mechanics, teachers or whatever else.

But why don't many Ruby companies do this? Why are we too
busy, but lawyers aren't? Have you _seen_ what kind of hours lawyers put in?
Have you never watched Suits, which of course is a 100% true-to-fact TV show
about lawyering? Fun fact: Lawyers are probably the only profession that
charges more than Ruby developers.

I think that other professions are not junior-adverse because those professions
have had turnover in their companies enough to learn the lesson about training
for the future. They have reached the point that we're at now where there just
isn't enough "senior" lawyers, mechanics or teachers to go around, shipping
things and growing the company gets _harder_ and so they start hiring _and
training_ brand-new talent. Lawyering, I can guarantee you, is an
older-than-your-grandfather profession. Programming on the other hand, isn't
(yet).

The principal running the school your kid goes to realises that the teachers
they have aren't going to be around forever. This is because teachers are not
yet solar-powered automatons. They hire these young upstarts from universities,
like my wife, to be the teachers of the future.

The grizzled mechanic that fixes your car for the last decade (or more) has
saved his pennies and is retiring off the coast of Australia on his catamaran.
Davy, the best young mechanic he has, is the one who will run the shop once ol'
grizzle-face is gone. Grizzle-face reckons she'll do, and I quote: "a bang up
job. She'll be right mate."

This Ruby community is still a young community where most people have been
doing this Ruby thing for less than 15 years. That's less than a generation.
If Rails was a person, that person would not even be old enough to have
graduated high-school, let alone make adult decisions. This is reflected
somewhat in the design choices of the framework, but that's a conversation for
another day.

We must make our succession plans to ensure the long-term viability of this
community. We must do this to ensure that we can continue to ship things fast
now and into the future. Other professions have succession plans because they've
lived long enough to realise that having them is the sensible thing to do. I
strongly feel like we are at that point now, or at least the cusp of it.

This emphasis on shipping things faster and "delivering value" is short-term
enough to be frustrating. The companies we're building and the code we're
writing will last longer than a month or two... usually. So we need to think
more long-term than shipping fast. For instance, Culture Amp -- the company I
work for -- has existed for 6 years. Who's to say it won't exist for another 6?
We must account for this sort of thing in our day-to-day work.

What we really need to think about is: who will look after the code that powers
our companies a year, or five years from now?  How do we ensure the long-term
survivability of our companies, and our community as a whole? What is our
succession plan? I think that our succession plan should be to hire and mentor
the talent of tomorrow, starting today.

So there's now two reasons why you should hire a junior:

* It's really hard to hire a senior developer at the moment
* It helps bolster your company and the community in the long-term, ensuring
  the stability of both

Let's talk about that third reason that I hinted at earlier: Juniors make teams
better.

## Juniors make teams better (take two)

Juniors make teams better is a big claim, but I have some evidence to back it
up. You might think that hiring a junior makes your productivity tank. While
that's true for the _short term_ it actually leads to _long term_ benefits for
the team the junior is in.

We know from a lot of experience that gender-diverse teams perform better than
either a team of all-men or a team of all-women. The same is true for teams that
are skill-diverse as well.

Hiring a junior means that things will need to be explained in simpler terms
than they were before. This makes things easier to understand for all members of
the team. Concepts are no longer talked about at a high-level all the time;
instead: people understand things in an easier way.

Teams that have a junior tend to document things more. For instance, a team I
was a part of recently documented the flow of an event through our main monolith
and some microservices. This documentation was done for the junior developer's
benefit and it consisted of a flowchart made up in Omnigraffle. The best part
about this piece of documentation was that we had something we could
_physically_ point to when talking about things we would only normally keep in
our head.

The funniest thing about that piece of documentation was that the _senior_
developers ended up referring to it more than the junior! We stuck it on a wall
and then talked about the structure of the system while pointing at the
different pieces in the diagram. It really helped cement the structure into our
heads.

If it wasn't for our junior developer, we wouldn't have written this
documentation in the first place.

This links into my next point:

Communication becomes _explicit_ out of necessity, rather than the _implicit_
style of communication usually found in all-senior developer teams. More
questions get asked by the junior than the senior because the junior wants to
learn. The answers to these questions not only help cement the junior's
knowledge, but they give the senior developer practice in explaining concepts
that they might not have otherwise.

Sometimes a question from a junior can even spark a thought about how to
structure something better in the code, or how to document a part of the system
in further detail so that everyone on the team can better understand it.

This is why we should hire junior developers: it makes our teams better. Things
are better understood. Documentation exists more on teams with juniors.  Clearer
communication channels open up out of necessity. The team is better for it.

Better teams ship better software and better software means happier users.

You may think that you need to hire only these best-of-the-best badasses because
your application is a large unmaintable behemoth monolith and only the badasses
can understand it. That you need seniors to navigate the spaghetti that is your
legacy code. Maybe you use technologies that only _true_ geniuses can
understand. All because you didn't listen to Sandi or Avdi.

That may indeed be the case. After all, if our code was simple and elegant,
would as many of us still be employed? But in every monolith, there is a small
bit of functionality that a junior developer can work on improving along with
their skills, when that junior is paired with a senior developer. The juniors
can practice their skills by fixing bugs and working with the seniors to develop
features.

This is the way we grow these juniors into the next generation of badasses. This
is the way that we get more mids and seniors in our companies: we make them
ourselves. Over time, they will become great developers if we invest in them.

After all, senior devs don't grow on trees, you must give juniors a chance.
Don't take just my word for this either. Here's a tweet from 4 years ago too:

https://mobile.twitter.com/buritica/status/492807632659689472

## Hiring juniors at Culture Amp

I know for a fact that with even a few months worth of training, these
developers can be productive. I know that juniors can be productive, because
we're making it happen at Culture Amp.

We've been giving a bunch of juniors a chance. In fact, we have ten juniors as a
part of our internal Junior Engineering Program. Each of these juniors comes
from a diverse background: They're not all 20-35, white, male, senior
developers.

At Culture Amp's Junior Engineering Program we provide structured training to
these 10 juniors over the course of 6 months. Two days a week (Monday and
Tuesday) they are doing "JEP work" and the other three days they're with their
teams. When the 6 months are up, they'll be fully-fledged developers, capable of
shipping things on their own. They'll then be working on their teams full-time.

During the JEP days we:

* Work on little toy projects
* Practice debugging real bugs in our real codebases
* Learn about database fundamentals like the differences between relational and
  document databases (we use both at Culture Amp)
* Learn about best practice software development with Ruby
* Go off and research new programming concepts

Then on the team days -- that's Wednesday, Thursday and Friday -- the juniors
apply this knowledge from the JEP days to solve problems, fix bugs and ship
features. They might not be shipping them _fast_ now, but they're shipping them.
The fast comes with practice. They do this by practicing their craft by pairing
up with senior developers. This is one way that Culture Amp is ensuring that our
company and this community keeps growing.

All ten of our juniors have only two things in common: they work at Culture
Amp and they have a great tenacity for learning, which I think is the best
quality to have as a developer. They may come across something that they don't
know, and each of them will go and try to learn about it, each in distinct ways.
It's so great to see.

My point here is that we've hired people who aren't all white, male, 25-34,
amazing senior Rails developers and yet... everything is still OK. In fact, it's
better than OK: it's awesome. Our senior developers and junior developers work
together on the team days on our applications and there's not a single fire or
brimstone as far as the eye can see.

## Hiring your own juniors

But how did Culture Amp come to have _ten_ juniors?


Now I'm not saying that you should do exactly what Culture Amp did and hire a
batch of juniors at once. Our interview process was _intense_: we interviewed
over 70+ people. We built a junior-friendly coding test from scratch and sent it
out to all the applicants. We then reviewed that coding test, giving _on
average_ seven-and-a-half pages of feedback per candidate. It ended up being
about 260 pages of feedback total.

After we reviewed the coding tests, we selected just 16 candidates and
interviewed them a second _and_ third time. The 2nd interview was more of a "get
to know you" culture-fit type deal, and the third interview was a technical
test, getting them to expand on their coding test a little.

I am not at all suggesting that you should run an interview process like this at
all. Culture Amp is a huge company and so we have a lot of structure and
processes in place to do that much hiring and support these juniors once we hire
them. It's why we're able to mentor ten of them at the time and still ship
features.

What I'm suggesting is that your company should start by hiring at least one
junior and mentoring them. Interview a couple and pick one from that batch. If
your company is at least 5 developers and at least one of them wants to mentor,
you can hire and support a junior. I believe in you. You should try to hire one
junior for every 5 non-junior members of your team. This will lead to a greater
skill-diversity in your team, and Google's Project Aristotle tells us that this
makes teams more productive, so you should definitely follow their advice.

Your next question might be: "what do _we_ (as a company) get out of hiring a
junior?" I think that's backwards. The thinking should be "we have earned so
much from the community, and now it's time to give back". "Ask what you can do
for your [community]" and all that. We have benefited from this community and
culture for over a decade now. To ensure the long-term viability of this great
Ruby community we have for at least another decade, we need to train up the
next generation. If you invest in the long term health of the community, it
will pay even greater dividends than what we have reaped already. In the long
run, you will have people who you have trained up specifically to work on your
application and who have the knowledge and skills to teach other people. In
the short term, you'll be bolstering your team's productivity with fresh
talent, ensuring the sustainability of your company over the long term.

### Risks

When I talk to people about hiring juniors, there's two main problems that they raise:

* What if we train them up and they leave?
* Won't this lead to a productivity hit?

So what if you do train them up and then they leave? That's a risk you take with
any hire of any skill level. If people are leaving your company, you should be
reflecting on why they're leaving in the first place. Was it really them, or
was it your company? Does your company have a culture that someone would want
to leave? Is your company focussed on building a culture that people want to
stay in? Is your company actively developing its people _and_ its software? Or
are they only interested in shipping code? What are you doing to make them stay?

To the second point of the productivity hit, that is an unavoidable truth.  Your
team will be _less_ productive once a junior joins it. There is an initial
productivity hit -- that's true -- but that plateaus out within 6 months if you
do it right. We've found that to be true for Lauren and Ramya at least, who have
now been at the company for 18 months and 10 months respectively.

One more thing: all of the juniors at Culture Amp have mentored our senior
developers on the most important programmer skill: patience. This is the thing
that juniors provide to your team that no senior can do. The seniors must
explain things to a junior, and that takes time. They might even have to
explain things more than once. Patiently explaining something to someone helps
seniors understand their own systems better and, in my extremely scientific
opinion, makes the seniors much better developers than if they only had to
explain things to other seniors. They need to slow down and methodically
explain things, which helps solidify the senior's knowledge.

Patience is a virtue that more developers should learn. The ironic thing about
me saying this is that I'm a naturally impatient person (just ask anyone who's
known me for more than 5 minutes)... who's getting more patient because of the
mentoring I'm doing. Huh, maybe it works.

At the end of training a junior for 6 months, rather than having one
developer, you have two developers.  Even if the junior is _half_ as
productive as the senior, then it's still a 1.5x growth in the productivity of
your team. If I told you today that you could ship things 1.5x faster in 6
months time with this one weird trick... you'd listen to me. Hiring a junior
is that one weird trick.

And hiring a junior is _so incredibly_ easy right now, as I mentioned near the
start of this talk. But where do you find these juniors?

## Finding Juniors

Well, let's start with Code Academies and universities.

Code academies get new developers to pay thousands of dollars to learn the
tricks of the trade. Sometimes, these new developers even get a "guarantee"
from the code academy that they'll get a job at the end of the course,
oftentimes that job is with an agency building cookie-cutter CMS-backed sites.
But hey, a job is a job. It's a foot in the door.

The code academies teach these newbies a range of programming skills. At the
end of this, the newbie developers have enough skills to know the basics of
things like HTML, CSS, JavaScript, Ruby and Rails and can usually find their way
around a generic Rails app easily enough. These people are very "green" and
then they're thrust out into the community to work at companies.

Unfortunately, due to our senior hiring addiction, we're not hiring many of
these fresh faces. One of the Culture Amp juniors that I mentioned earlier, Jaime, is an
exception. He came from the Coder Academy here in Melbourne.

The code academies are producing brand new talent at a faster rate than we're
hiring. These people are left to struggle for months at a time in developing
their skills before they can even get a look in at a larger, non-agency
company. Our collective bar is too high for these juniors to get a look in.
I've spoken to many juniors in that position. Companies want to hire people
with experience, but they don't want to give them the experience in the first
place. With the talent pool run dry, it's time we started hiring these juniors
and training them up.

Not all of these graduates have the time to spend doing that skill
development, as they often have full time jobs or other responsibilities to
take care of. Thankfully, they get a lot of assistance from their code
academies after they've graduated.

The senior developers of the future are coming from the code academies and
universities of today. More companies need to make mentorship / apprenticeship
a part of what they do. It's vital for the sustainability of the company. The
students that graduate from code academies and universities are eager to learn
and are, in my experience, very highly motivated. We've hired 3 people from
places like this: Jaime, Rebecca and Jasmine. They're great and each brings
their own set of skills to our company.

There are definitely juniors who have that same kind of eagerness-to-learn and
motivation who have never been to a code academy. These people have learned by
themselves and by being mentored by people in the community. Out of the
Culture Amp juniors I mentioned before, two fit this bill: Namibia and Julie.
While they haven't gone through intensive coding schools or universities, they
still bring to Culture Amp a great set of skills that they've built up
themselves. Their ability to learn on their own far exceeds those who have
been classically taught.

We interviewed a bunch of other people who fit this bill and while we didn't
place them at Culture Amp this round, they would make great juniors to hire in
the future, or for other Ruby companies.

The people who come from coding academies, universities and who are self-
taught are the future brilliant developers of this community and we should
hire and start training them _today_.

### The Talent Code

There's a great book I encourage you all to read: it's called _The Talent
Code_. As the subtitle says "Greatness isn't born. It's grown." It's about 300
pages long. The book covers how skills of all varieties are grown in sports,
music and plenty of other areas. All the industries that are covered in the
book have active mentorship and apprenticeship programs. Yet, this is not
deeply cared about in the programming community for reasons mentioned earlier:
we're still quite a young community; we aren't mature enough to think long-
and-hard about mentorship and the sustainability of talent in this community
within our companies. We have events like the Rails InstallFests, and Rails
Girls, but we need more mentoring and junior opportunities within our
companies. These opportunities will bridge the gap between these events and
doing Rails- as-a-job. We need to focus more on growing talent within our
companies and community.

I'll let you in on the secret that's in the Talent Code: for anyone to get
better at anything, they need to practice the hell out of it, have a passion
for it _and_ they need to have a good mentor who is encouraging and can
provide sound advice. Okay, now you don't have to read 300 pages to learn
that. Scratch that book off your list.

How do we expect to have more seniors to hire if we're not hiring those non-
senior people and letting them improve their skills by practicing on real
world applications? They do not simply pop into existence. This isn't the
Matrix: we can't just plug in, and a few seconds later we just _know_ Rails.
They have to be taught. We have to grow talent if we want talent.

So many people are already talking about how good it would be to hire and mentor
juniors. Let's start doing it. Let's start having more of these conversations
to the management in our companies.

When you start interviewing them, you'll be pleasantly surprised at who you
find. I certainly was.

## Mentorship

OK, so you know now where to get juniors from, but what do you do once you
have them? They're going to need a lot of love and attention; you can't just
put them in the corner and expect them to thrive. Think more of them like a
puppy than a cactus: the puppy needs love and attention and some training, but
the cactus needs only sunshine and some water. The cactus is indifferent to
your love or your attention. Junior developers don't grow into senior
developers with just sunshine and water. And they don't do it just by
practicing, either. They need mentorship!

I used to help run the Melbourne Ruby Hack Night and it's a judgement-free
environment where anyone and everyone can bring along a Ruby project and work
on it. Some people are even there for the first time learning about Ruby
itself, which is so great to see. These Hack Nights work because these new
developers feel safe and welcome and that no question is too "dumb" to ask.

You could start these events in your cities. They're great for introducing new
developers to Ruby. Just like the Rails InstallFests and Rails Girls events,
they provide an avenue for new developers to enter this community.

You can also start mentoring at your company by fostering that Hack Night-
esque environment. It should be OK to put up your hand and ask a question
about _anything_. If the questioner is getting eyerolls, sighs, or other
passive aggressive signals from someone else, then that's not the kind of
environment where a junior is going to learn. That doesn't happen much in the
Ruby community because we're so good at building fostering environments, and
that whole MINASWAN ethos helps us do it. But very clearly outlining to
juniors that it's OK to ask _any_ question about _anything_ is a great place
to start. And repeat that as much as possible, too.

A great way to build that kind of hack-night-esque fostering environment is to
encourage pair programming. Pairing with juniors on small tasks initially is a
great way to build up their confidence. When I've been mentoring juniors, the
number one thing that I find that they're lacking isn't the skill, but the
confidence. They know the answer, but they aren't sure if it's the _right_
answer. They question if they're using the right syntax or even if they should
be writing the code that particular way. When a senior pairs with a junior,
they can encourage them to try out things and learn from the things that they
try. If the junior gets it wrong, the senior can ensure them that it's OK to
get things wrong and to guide them back on track. Pairing is the quickest way
to upskill a junior and I can highly, highly recommend it.

Remember: puppy, not cactus.

Pairing also helps reinforce your own knowledge. If you can't explain
something to someone clearly, then you do not understand it well enough
yourself. Pairing is helpful to the junior because they get knowledge out of
it, but it's also helpful to the senior: they learn how to share what's in
their brain with other people in a clearer fashion. As I said before, it also
teaches the most valuable skill of all: patience.

What should you pair with your junior on? Well, Lydia Guarino has some good
tweets about that.

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">5) For junior devs, a good guideline for scope is something that can be completed in 2-3 days. You want to keep your feedback loop short.</p>&mdash; Lydia Guarino (@lydiaguarino) <a href="https://twitter.com/lydiaguarino/status/720090654575996928">April 13, 2016</a></blockquote>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">5) Tasks with scope of more than 3 days are tasks that are not defined well enough. Break them down further.</p>&mdash; Lydia Guarino (@lydiaguarino) <a href="https://twitter.com/lydiaguarino/status/720090891231166464">April 13, 2016</a></blockquote>

I agree with both of these. Juniors thrive best when they're given quick wins.
You want that nice tight feedback loop to keep their confidence growing. Every
time they "win" at code, their confidence gets that little bit more boosted.
At Culture Amp, we started our juniors out on fixing bugs or working on little
features and then moved them up to trickier bugs and harder features from
there. Most bugs didn't take more than a day for the juniors to fix.

Once they've built up a bit of confidence, you can let them go solo on a task.
There isn't a set timeframe for when this happens; it's all about how
confident the junior is with their own abilities. Let them loose on something
small and make it clear that they can ask any questions about what they're
doing and that there is no wrong way of doing it.

Once they're done, get them to submit their work in a pull request and then --
this part's important -- sit together and review it.

Sitting together is important here because "why are you doing this?" written
in text has no emotion, compared to it spoken with body language. Juniors may
interpret a "why are you doing this?" comment as aggressive like "UGH! Why are
you doing this?".

Focussing on in-person communication helps establish a rapport between the
developers much better than text-based communication ever will.

If a junior has made a mistake in the pull request then you can discuss it
with them and correct the mistake. This way, that mistake will never make it
to a live production environment. Pull request reviews are good for that.

Code review also allows the senior to assess how well the junior has been
doing on the tasks they've been given. If they're doing well on a 2-day task,
then it's probably going to be OK to give them a 4-day task too. If not, then
some more mentoring may be required. And that's perfectly OK. Give them that
mentorship and direction, and try again.

### Feeling welcome

Ultimately, your mentorship should be about making the junior feel welcome and
safe within your team. In fact, this should be what's happening with
_everyone_ in your team. Remember Google's Project Aristotle that I mentioned
before wherein [they attempted to find how to build effective
teams](https://rework.withgoogle.com/blog/five-keys-to-a-successful-google-
team/). They interviewed hundreds of their own employees and they came up with
5 things:

![Google's 5 key dynamics for effective teams](https://lh3.googleusercontent.com/eQ_WsRq5-q-m_41eEI6GLEObqpxBYJd1pm96gIa-eRSn-QXlPjwO5K6O-DHU8sxny3ChnIQE0mjpnXaaW7QAhQ=s0)

The #1 item on this list is "Psychological safety": "Team members feel safe to
take risks and be vulnerable in front of each other." You probably recognise
that some of these things sound a lot like [Maslow's hierarchy of
needs](https://en.wikipedia.org/wiki/Maslow%27s_hierarchy_of_needs), so that
Maslow guy was probably onto something.

The remainder of this list is not to be discounted. Dependability, Structure &
Clarity, Meaning and Impact are all vital to junior developers progressions.
When you hire a junior developer, keep these things in mind and ask yourself
regularly if you're following along with them. These things should underpin
everything you do with the junior.


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
