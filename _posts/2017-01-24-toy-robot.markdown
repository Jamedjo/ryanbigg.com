---
wordpress_id: RB-375
layout: post
title: Toy Robot
published: false
---

The "Toy Robot" exercise is a famous exercise, commonly used as an interview exercise for a programming job. The description is fairly simple, but it has some underlying complexity which can lead to some difficulties for anyone attempting it.

In this guide, I'm going to go through how I would implement the Toy Robot exercise myself in Ruby, just for demonstration purposes. I'll be building it up piece-by-piece with the overall aim to be to help anyone reading how to think through and implement this problem.

While writing this post I've actually revised my approach to the problem several times. Despite having done it a few times myself before, each time I've done it I've refined the approach I took. This blog post is no exception; the code inside it has gone through several revisions while I worked out how to structure the code and explain my thought process. What you're seeing here is a final version, rather than a first draft. Such is the power of a blog post that can be very easily edited ;)

I'll be assuming a basic level of familarity with Ruby (i.e. you know what a class, module and method are), but I may accidentally skip over some things. If I do, please ask questions about it in the comments if you don't understand anything. I won't bite :)

It's not intended to be a _perfect_ implementation of the Toy Robot because like everything in programming, there's more than one way to do anything.

## Description

Let's start out with the description:

> The application is a simulation of a toy robot moving on a square tabletop, of dimensions 5 units x 5 units. There are no other obstructions on the table surface. The robot is free to roam around the surface of the table. Any movement that would result in the robot falling from the table is prevented, however further valid movement commands are still allowed.
>
> The application reads a file using a name passed in the command line, the following commands are valid:

> ```
> PLACE X,Y,F
> MOVE
> LEFT
> RIGHT
> REPORT
> ```

> * PLACE will put the toy robot on the table in position X,Y and facing NORTH, SOUTH, EAST or WEST.
> * The origin (0,0) is the SOUTH WEST most corner.
> * All commands are ignored until a valid PLACE is made.
> * MOVE will move the toy robot one unit forward in the direction it is currently facing.
> * LEFT and RIGHT rotates the robot 90 degrees in the specified direction without changing the position of the robot.
> * REPORT announces the X,Y and F of the robot.

> The file is assumed to have ASCII encoding. It is assumed that the PLACE command has only one space, that is PLACE 1, 2, NORTH is an invalid command. All commands must be in upcase, all lower and mixed case commands will be ignored.

Clocking in at nearly 250 words, that's quite a lot to process all at once. So we won't be processing this all at once. We'll be breaking it down into little chunks that we can tackle, one at a time. When we've implemented one chunk, we'll move onto the next one. Eventually, we'll chain these chunks together and make our toy robot move, turn and report!

## Simplifying the problem

Before we write any code, we should break this problem down into little chunks that we can solve piece by piece. We know that our robot needs to be placed and once it's placed it needs to respond to commands to move, turn and report its location. We should pick out one instruction from this set and implement that.

But first, let's visualise what the robot and the tabletop might look like:

<center>
<svg id="table" width="250" height="250">
    <desc>Created with Snap</desc><defs></defs><line x1="20%" x2="20%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="20%" y2="20%" stroke="#000000" style="stroke-width: 2;"></line><line x1="40%" x2="40%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="40%" y2="40%" stroke="#000000" style="stroke-width: 2;"></line><line x1="60%" x2="60%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="60%" y2="60%" stroke="#000000" style="stroke-width: 2;"></line><line x1="80%" x2="80%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="80%" y2="80%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="0" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="0" y1="0" y2="100%" stroke="#000000" style="stroke-width: 10;"></line><line x1="100%" x2="100%" y1="100%" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="100%" y1="100%" y2="100%" stroke="#000000" style="stroke-width: 10;"></line><circle cx="50%" cy="52%" r="15"></circle><line x1="50%" x2="50%" y1="50%" y2="42%" stroke="#000000" style="stroke-width: 5;"></line></svg>
</center>

The grid represents our tabletop, and the little icon in the middle is our robot. The little "turret" on our robot indicates which direction its facing. This is so far a good visualisation of the problem that we're trying to work out.

If our robot is given a `MOVE` command, then it should "move one unit forward in the direction it is currently facing." A single `MOVE` command issued to our robot on the tabletop would mean that the robot would end up like this:

<center>
<svg width="250" height="250">
    <desc>Created with Snap</desc><defs></defs><line x1="20%" x2="20%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="20%" y2="20%" stroke="#000000" style="stroke-width: 2;"></line><line x1="40%" x2="40%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="40%" y2="40%" stroke="#000000" style="stroke-width: 2;"></line><line x1="60%" x2="60%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="60%" y2="60%" stroke="#000000" style="stroke-width: 2;"></line><line x1="80%" x2="80%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="80%" y2="80%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="0" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="0" y1="0" y2="100%" stroke="#000000" style="stroke-width: 10;"></line><line x1="100%" x2="100%" y1="100%" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="100%" y1="100%" y2="100%" stroke="#000000" style="stroke-width: 10;"></line><circle cx="50%" cy="32%" r="15"></circle><line x1="50%" x2="50%" y1="23%" y2="26%" stroke="#000000" style="stroke-width: 5;"></line></svg>
</center>

You can probably guess what several `MOVE` commands in a row will do to the robot: it will keep obeying those commands and moving up the table, in the direction it is facing.

The `MOVE` instruction will be fairly easy to implement, since it is just about moving the robot to a new location. Let's say in the above diagrams that the robot started at `(0,0)` and that the `MOVE` command moved it to `(0,1)`. Another `MOVE` command would move it to `(0,2)` and so on.

Now what if our robot could only move in a straight line? If we thought of the starting position of the robot as `0`, then a `MOVE` would mean that the robot would then be at `1`, and another one would mean that it would be at `2`.

A good way of representing this straight-line-with-numbers-on-it would be a number line:

![Toy Robot starting at 0](/images/toy_robot/toy-robot-0.png)

The "robot" will initially start at 0, and a `MOVE` command will move the "robot" to the right one number. So if the instructions were just:

```
MOVE
MOVE
MOVE
```

The robot would then end up on 3:

![Toy Robot moved to 3](/images/toy_robot/toy-robot-3.png)

By making our "tabletop" into a single line, it really simplifies our problem. Our robot now only has two directions it will move: "forward" or "backward" along the number line. To simplify it further, we will choose to write code that will only mean our robot can move "forward" to start with.

Moving doesn't have any purpose yet if we can't ask the robot to tell us where it is, so we should implement the `REPORT` command too along with the `MOVE` command. If we asked the robot to `REPORT` its location on the above line, it should tell us that it's at position `3`.

So this is where we'll start: with the `MOVE` and `REPORT` commands and a number line instead of a table top. We're going to ignore `PLACE`, `LEFT` and `RIGHT` commands for the time-being. `PLACE` specifies an X, Y, and facing direction for our robot, but thanks to this simplification of our problem, we don't have any concept of X, Y or facing direction for the robot. All we have is its position on the number line. We'll assume a starting place of `0` for the time being. We'll ignore the `LEFT` and `RIGHT` commands for the time being, as they don't make sense when the robot can only move two directions along the number line.

Let's take a look at implementing these two commands in this much simpler environment.

## The `MOVE` and `REPORT` commands

To start with implementing these two instructions, we'll create a new Ruby project using the `bundle gem` command, which comes from the [Bundler](https://bundler.io) gem. If you've not got the Bundler gem installed yet, run `gem install bundler` first to install it.

Once Bundler's installed, run this command:

```
bundle gem toy_robot
```

This directory generated by `bundle gem` will provide us a nice little base project for building out our toy robot, and it even comes with a test directory (`spec`), which we'll be making great use of, to make sure our robot does what we want it to do.

We'll be test-driving this exercise because, like many other projects, this one will be evolving over time and changes that we make to it may break functionality. By having the tests in place and regularly checking their status, we can make sure that each part of our project is functioning the way it should be.

It may be tempting to write this code without any tests and play around with it yourself. By all means, go ahead. I am choosing to write tests here in this guide because it is what would be expected if this code was submitted as part of an interview process.

Additionally, by writing the test first it gives us time to think about our design of the code before we begin writing it. Consider this practice for writing tests!

To begin with, we'll remove the placeholder tests that live at `spec/toy_robot_spec.rb`. We're not going to need these tests, as they just demonstrate how we can test our code. This blog post will do that anyway!

Let's create a new file called `spec/toy_robot/robot.rb` and put this code there:

```ruby
require "spec_helper"

describe ToyRobot::Robot do
  subject { ToyRobot::Robot.new }

  it "moves 3 spaces" do
    3.times { subject.move }
    expect(subject.position).to eq(3)
  end
end
```

This test will initialize a new instance of the `ToyRobot::Robot` class as the `subject` of our tests, passing in `0`. This is the initial position of the robot on our number line. The test will then tell the Robot to move 3 times and then ask the robot to tell us its position. When the robot does that, we're expecting that the robot tells us that its location is `3`. Our robot will end up here on the line:

![Toy Robot moved to 3](/images/toy_robot/toy-robot-3.png)

We've called the method that tells us the position of the robot `position` because it more clearly indicates the intent of the method than `report`. If we called it `report`, could we tell from just the method name what it was going to return?

Rather than manually testing the process of telling the robot to move 3 times (by calling `move` 3 times) and then checking what `position` returns, we've written a test which will allow us to very quickly test that these two functions of the robot are performing correctly. We'll run this test in a moment.

We've referred to the `Robot` class under the `ToyRobot` module as our application is called `ToyRobot` and the container for the robot logic is going to be the `Robot` class.

Before writing any code, we should first validate that the test we just wrote fails. This test is intended to prove that our code works and if our test worked already, how could we know that it was really testing that code in the first place? It's always a good idea to make sur by running the test before writing the code. We'll run the test with this command:

```
rspec spec
```

The test will tell us this:

```
...toy_robot/spec/toy_robot/robot_spec.rb:3:in `<top (required)>':
  uninitialized constant ToyRobot::Robot (NameError)
```

This error tells us that the `ToyRobot::Robot` constant doesn't exist. This constant needs to be defined as a class, as our test is trying to call `new` on this constant and it is therefore expecting new instances to come from that call of `new`.

The place to define this constant is in `lib/toy_robot/robot.rb`. This is to follow naming conventions in Ruby which is that namespaces such as `ToyRobot` have their own directory under `lib`, (`lib/toy_robot`) and then classes inside those namespaces are defined in a file matching that name, but downcased: `lib/toy_robot/robot.rb`.

Here's all we're going to put in `lib/toy_robot/robot.rb` to begin with:

```ruby
module ToyRobot
  class Robot

  end
end
```

We've only put these few lines of code in this file as this is all our test is asking for; it's complaining about an uninitialized constant and this code will initialize that constant. We don't want to overstep and do more than what the test asks for, else we may write untested code. The goal here is to do the absolute minimum required to get the test to pass.

When we run the test again, it will still complain about the uninitialized constant:

```
...toy_robot/spec/toy_robot/robot_spec.rb:3:in `<top (required)>':
  uninitialized constant ToyRobot::Robot (NameError)
```

Even though we've defined and therefore initialized this constant, it hasn't been loaded. This is because we haven't told anything to load the file that contains this constant. How can we make our test know about this file? Well, at the top of the test file, is this line:

```
require "spec_helper"
```

This line requires the `spec/spec_helper.rb` file from the application, which consists of this code:

```
$LOAD_PATH.unshift File.expand_path("../../lib", __FILE__)
require "toy_robot"
```

This code contains some configuration which adds the `lib` directory from the application to the `$LOAD_PATH`. It does this by first using `File.expand_path("../../lib", __FILE__)` to get an absolute path to that directory, such as `/Users/ryanbigg/code/toy_robot/lib`, and then uses `unshift` to add that path to the beginning of the `$LOAD_PATH` array.

The `$LOAD_PATH` array is configured automatically by RubyGems and Bundler, and typically consists of all the `lib` directories for any gem dependencies of your application. It's what informs Ruby of where it can find files to use when `require` is called. One example of what's available in the `$LOAD_PATH` is the path to the code which runs the RSpec tests. We're just adding another path to this list.

The next line requires the `lib/toy_robot.rb` file, but we don't need to specify the `lib` directory here, as that is a part of the `$LOAD_PATH` thanks to the first line. We can leave the `.rb` off too, as when you `require` files in Ruby it knows that you want a `.rb` file already. This is why we can simply do `require "toy_robot"`.

This `lib/toy_robot.rb` file currently consists of this:

```ruby
require "toy_robot/version"

module ToyRobot
  # Your code goes here...
end
```

We could've defined our `Robot` class directly in the `ToyRobot` module here, but it is better to leave this file for more generic configuration for the `ToyRobot` module (if we needed it). If we defined all our classes in here, over the life of the project this file might get very big and hard to navigate!

The issue in our test is that we're not requiring the `toy_robot/robot` file in `lib/toy_robot.rb`. Let's add that `require` at the top of `lib/toy_robot.rb` now:

```ruby
require "toy_robot/version"
require "toy_robot/robot"

module ToyRobot
  # Your code goes here...
end
```

With this `require` added, our test will get a little further when we run it again:

```
Failure/Error: subject { ToyRobot::Robot.new(0) }

ArgumentError:
  wrong number of arguments (given 1, expected 0)
# ./spec/toy_robot/robot_spec.rb:4:in `initialize'
# ./spec/toy_robot/robot_spec.rb:4:in `new'
```

In the `subject` call for our test, we're expecting to be able to call `new` with one argument (which will in turn call `initialize`), but by default a class's `initialize` method does not take any arguments at all. Let's define an `initialize` method in our `ToyRobot::Robot` class:

```ruby
module ToyRobot
  class Robot
    def initialize(position = 0)
      @position = position
    end
  end
end
```

By defining an `initialize` method like this, we could invoke `ToyRobot::Robot.new` and pass in any position that we wished, or we could elect to leave the position out to default it to `0`, just as we do in the `subject` for our test. Speaking of, let's run our test again and see what happens:

```
1) ToyRobot::Robot moves 3 spaces
   Failure/Error: 3.times { subject.move }

   NoMethodError:
     undefined method `move' for #<ToyRobot::Robot:...>
```

Our test is now able to initialize a new instance of the `ToyRobot::Robot` class, but that new instance does not have the `move` method defined. This makes our test fail with a `NoMethodError` exception.

Let's define this method now in `lib/toy_robot/robot.rb`:

```ruby
module ToyRobot
  class Robot
    def initialize(position = 0)
      @position = position
    end

    def move

    end
  end
end
```

Again, we're just doing the bare minimum to get the test to pass. The `move` method doesn't need to do anything; our test failure was because the method did not exist. When we run the test again, we'll see that the `position` method is now what the test wants:

```
Failure/Error: expect(robot.position).to eq(3)

NoMethodError:
  undefined method `position' for #<ToyRobot::Robot:...>
```

We'll define this method too:

```ruby
module ToyRobot
  class Robot
    def initialize(position = 0)
      @position = position
    end

    def move

    end

    def position
      @position
    end
  end
end
```

Running the test once more will no longer show a `NoMethodError` exception, but instead will tell us that things aren't what the test expects them to be:

```
Failure/Error: expect(subject.position).to eq(3)

  expected: 3
       got: 0
```

The test is calling `subject.position` and expecting the value to be 3. We could write some code that makes the `Robot` instance track which current number its up to and then adds 1 to that number every time `move` is called, or we could cheat and make the `position` method always return 3 just to make our test pass. Let's do the latter:

```ruby
def position
  3
end
```

When we run our test one more time, it'll pass:

```
1 example, 0 failures
```

Well that was easy! We got by without writing very much code at all. However, our Robot is extremely broken in that it doesn't move _at all_ and always tells us that it is at a position of `3`. We're going to need more tests if we want our Robot to behave!

Let's write a nearly identical test underneath the one we already have in `spec/toy_robot/robot_spec.rb`:

```ruby
require "spec_helper"

describe ToyRobot::Robot do
  it "moves 3 spaces" do
    3.times { subject.move }
    expect(subject.position).to eq(3)
  end

  it "moves 4 spaces" do
    4.times { subject.move }
    expect(subject.position).to eq(4)
  end
end
```

This new test tests that when we tell our robot to move 4 times and then tell us its position, it should tell us `4`. It's going to be very hard to write some code that makes `position` return `3` for the first test and then `4` for the second test, so let's actually implement the proper code for `move`.

To do that, we're going to need to increment the `@position` variable every time `move` is called.

Let's change the code in `lib/toy_robot/robot.rb` to this:

```ruby
module ToyRobot
  class Robot
    def initialize(position = 0)
      @position = position
    end

    def move
      @position += 1
    end

    def position
      @position
    end
  end
end
```

The `move` method has changed to add one to that number every time it's called, and then `position` returns the value of `@position`.

We've made only a few small changes to our code, but it should make the tests pass. Let's find out by running it again:

```
ToyRobot::Robot
  moves 3 spaces, then reports
  moves 4 spaces, then reports

2 examples, 0 failures
```

Great! Both of our tests are now passing. We can do one little bit of tidy up here which is to turn our `position` method into an `attr_reader`:

```ruby
module ToyRobot
  class Robot
    attr_reader :position

    def initialize(position = 0)
      @position = position
    end

    def move
      @position += 1
    end
  end
end
```

This does exactly the same thing as our `position` method definition, but in just one simple line.

Our robot currently only moves one direction along the number line, but we need to keep in mind that the robot will eventually need to move up, down, left and right along the "tabletop". It's worth pointing out that the description of the problem doesn't refer to these directions as up, down, left and right, but rather `NORTH`, `SOUTH`, `EAST` or `WEST`. So we should be careful to do the same. From now on we'll be using these compass directions, instead of the regular directions.

This will make it easy for us later on as we won't need to think that north means up, west means left, east means right and south means down.

 Rather than implementing the remaining three movement directions (`WEST`, `NORTH` and `SOUTH`), let's just make it so that the robot can move "west" along our number line.

## Moving left

Our robot should be able to move "west" as well as "east" along the number line:

![Toy Robot moving west](/images/toy_robot/toy-robot-move-left.png)

Before we do that, we'll change our code so that the `move` method is called `move_east`; just so it's different to the method which will move our robot west, `move_west`. Let's change the `move` method in the tests first, so that we have some failing tests to assert that our code changes will be correct. Let's change the tests in `spec/toy_robot/robot_spec.rb`:

```ruby
require "spec_helper"

describe ToyRobot::Robot do
  subject { ToyRobot::Robot.new(0) }

  it "moves 3 spaces east" do
    3.times { subject.move_east }
    expect(subject.position).to eq(3)
  end

  it "moves 4 spaces east" do
    4.times { subject.move_east }
    expect(subject.position).to eq(4)
  end
end
```

With these changes we've updated the description of the test to better reflect what is happening here, and we've changed the `robot.move` call to `robot.move_east`. When we run these tests, we'll see that they're now failing:

```
Failure/Error: 3.times { robot.move_east }

  NoMethodError:
    undefined method `move_east' for #<ToyRobot::Robot:... @position=0>
```

Ok, now that we have some failing tests that are checking for the newly _correct_ implementation of this code, let's fix the code itself. We'll open `lib/toy_robot/robot.rb` and change the `move` method to this:

```ruby
def move_east
  @position += 1
end
```

Running our tests again will show that they're working:

```
2 examples, 0 failures
```

We're now at a good spot where we can add our method that moves the robot to the west of the number line. We've got some tests ensuring that the current `move_east` behaviour will remain the same, even if we make these new changes to the code. If the robot is issued an instruction to move west, it should indeed move west along the line. Three "move west" instructions on a new robot should put the robot here on the line:

![Toy Robot at -3](/images/toy_robot/toy-robot-minus-3.png)

Let's add a new test for this to `spec/toy_robot/robot_spec.rb`:

```ruby
it "moves 3 spaces west, then reports" do
  3.times { subject.move_west }
  expect(subject.position).to eq(-3)
end
```

When we run this new test, it'll tell us what we already knew: the `move_west` method is undefined:

```
Failure/Error: 3.times { subject.move_west }

NoMethodError:
  undefined method `move_west' for #<ToyRobot::Robot:... @position=0>
  Did you mean?  move_east
```

The `move_east` method increments the position of the robot, and so the `move_west` method should _decrement_ the position of the robot. Let's add this new method to `lib/toy_robot/robot.rb` now:

```ruby
def move_west
  @position -= 1
end
```

Running our tests again will once again show that everything is happy:

```
3 examples, 0 failures
```

Our robot is now moving west and east, which are two of the four directions that the robot needs to move along our table top. However, there's an imbalance in our tests: we've got two tests for moving `east`, one for 3 movements and one for 4, but only one test for `west`. Just to be safe, we should add another test for `move_west`. Otherwise, we _could_ very easily write a variation of `move_west` which moved the robot to the correct position according to that one test! For this particular test, it would look like this:

```ruby
def move_west
  @position = -3
end
```

That code in `move_west` will make the test pass. Go on, try it. We should try to be defensive about this sort of thing in our tests in order to make our code more robust to human errors. Let's write one more little test for `move_west`:

```ruby
it "moves 4 spaces west, then reports" do
  4.times { subject.move_west }
  expect(subject.report).to eq(-4)
end
```

Running this test again show everything working:

```
4 examples, 0 failures
```

That is, unless you still have that most recent `move_west` change in place. If you do, switch it back to this and try again:

```ruby
def move_west
  @position -= 1
end
```

Now that we've got our robot moving west and east along our number line, let's reverse the simplification of our problem a little by introducing a second number line; turning our number line into two intersecting number lines.

## Moving north and south

To make our robot move north, south, east and west, we'll move the robot along two intersecting number lines, shown here as a grid with coordinates representing each intersecting position on our number lines:

<center>
<svg id="table" width="250" height="250">
    <desc>Created with Snap</desc><defs></defs><line x1="20%" x2="20%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="20%" y2="20%" stroke="#000000" style="stroke-width: 2;"></line><line x1="40%" x2="40%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="40%" y2="40%" stroke="#000000" style="stroke-width: 2;"></line><line x1="60%" x2="60%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="60%" y2="60%" stroke="#000000" style="stroke-width: 2;"></line><line x1="80%" x2="80%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="80%" y2="80%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="0" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="0" y1="0" y2="100%" stroke="#000000" style="stroke-width: 10;"></line><line x1="100%" x2="100%" y1="100%" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="100%" y1="100%" y2="100%" stroke="#000000" style="stroke-width: 10;"></line><circle cx="50%" cy="52%" r="15"></circle><line x1="50%" x2="50%" y1="50%" y2="42%" stroke="#000000" style="stroke-width: 5;"></line>
    <text x="5%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 0)
    </text>
    <text x="25%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 1)
    </text>
    <text x="45%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 2)
    </text>
    <text x="65%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 3)
    </text>
    <text x="85%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 4)
    </text>
    <text x="5%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 0)
    </text>
    <text x="25%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 1)
    </text>
    <text x="45%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 2)
    </text>
    <text x="65%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 3)
    </text>
    <text x="85%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 4)
    </text>
    <text x="5%" y="51%" font-family="Titillium Web" font-size="12">
    (2, 0)
    </text>
    <text x="25%" y="51%" font-family="Titillium Web" font-size="12">
    (2, 1)
    </text>
    <text x="65%" y="51%" font-family="Titillium Web" font-size="12">
    (2, 3)
    </text>
    <text x="85%" y="51%" font-family="Titillium Web" font-size="12">
    (2, 4)
    </text>
    <text x="5%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 0)
    </text>
    <text x="25%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 1)
    </text>
    <text x="45%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 2)
    </text>
    <text x="65%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 3)
    </text>
    <text x="85%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 4)
    </text>
    <text x="5%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 0)
    </text>
    <text x="25%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 1)
    </text>
    <text x="45%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 2)
    </text>
    <text x="65%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 3)
    </text>
    <text x="85%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 4)
    </text>
   </svg>
</center>

We refer to the horizontal rows of the grid as `x`, and the vertical as `y` typically when using cartesian plane, but for this problem we'll refer to them as `east` and `north`. These variables will indicate the `east` and `north` position of our robot. If our robot was to move forward from its current position, it would end up on the grid spot marked `(2, 3)`, which is a short way of writing `(x = 2, y = 3)`, or in our terms `(east = 2, north = 3)`.

The `(0, 0)` point of our grid is the "south west" (bottom left) corner because this is what our problem description asks for:

> The origin (0,0) is the SOUTH WEST most corner.

Incidentally, by doing this it will make it easier for us to determine if our robot is going to go outside the boundaries of the table, which is important because the problem description says this:

>  Any movement that would result in the robot falling from the table is prevented

More on that later. Let's get our move actions all working first.

When we tell our robot to `move_east`, it will increase the value of `east`, and when we tell it to `move_west` it will decrease the value of `east`. Similarly, if we tell the robot to move north, then we should increase the value of `north`, and if we tell it to move south then we'll decrease the value of `north`.

Let's work in small increments towards our goal. We'll start by changing the code we already have to use `@east`, instead of `@position`. Once we've done that, then we'll implement both `move_north` and `move_south`.

To start with, we'll rename the `@position` variable to `@east`, so that the name more accurately represents the data that the variable contains. Let's first update our test in `spec/toy_robot/robot_spec.rb` to call a method called `east`, instead of `position`:

```ruby
require "spec_helper"

describe ToyRobot::Robot do
  subject { ToyRobot::Robot.new(0) }

  it "moves 3 spaces east" do
    3.times { subject.move_east }
    expect(subject.east).to eq(3)
  end

  it "moves 4 spaces east" do
    4.times { subject.move_east }
    expect(subject.east).to eq(4)
  end

  it "moves 3 spaces west" do
    3.times { subject.move_west }
    expect(subject.east).to eq(-3)
  end

  it "moves 4 spaces west" do
    4.times { subject.move_west }
    expect(subject.east).to eq(-4)
  end
end
```

Running our tests will show that this change breaks them all:

```
Failure/Error: expect(subject.east).to eq(4)

NoMethodError:
  undefined method `east' for #<ToyRobot::Robot:0x007feb3f0b76d8 @position=4>
```

With our tests now broken, we can make changes to our code to make the tests pass again. Let's do a similar rename inside of `lib/toy_robot/robot.rb`:

```ruby
module ToyRobot
  class Robot
    attr_reader :east

    def initialize(east = 0)
      @east = east
    end

    def move_east
      @east += 1
    end

    def move_west
      @east -= 1
    end
  end
end
```

We should now run our tests to make sure that everything is still working after this little change. We'll run them with `rspec spec` and see that they are indeed still working:

```
4 examples, 0 failures
```

Great! Let's now write two tests for the `move_north` method in `spec/toy_robot/robot_spec.rb`. These two tests will be very similar to the ones for `move_west` and `move_east` methods, in that we'll move the robot both 3 and 4 spaces and verify that the robot tracks its correct position.

```ruby
it "moves 3 spaces north" do
  3.times { subject.move_north }
  expect(subject.north).to eq(3)
end

it "moves 4 spaces north" do
  4.times { subject.move_north }
  expect(subject.north).to eq(4)
end
```

In these tests we call `move_north` 3 and 4 times and then check the value of `north`. The value should be `3` and `4` respectively. Let's run these tests now and see what happens:

```
Failure/Error: 3.times { robot.move_north }

NoMethodError:
  undefined method `move_north' for #<ToyRobot::Robot:0x007fd33a08aad8 @east=0>
  Did you mean?  move_west
```

Our `move_north` method is undefined. Let's define it as a blank method inside the `ToyRobot::Robot` class:

```ruby
def move_north
end
```

Running the test again will then show us that the `north` method is missing:

```
Failure/Error: expect(subject.north).to eq(3)

NoMethodError:
  undefined method `north' for #<ToyRobot::Robot:0x007fd34402d0e0 @east=0>
```

Let's add this to the `attr_reader` list at the top of our class:

```ruby
attr_reader :east, :north
```

Running our tests again will show that `north` is not changing at all:

```
Failure/Error: expect(subject.north).to eq(3)

  expected: 3
       got: nil

  (compared using ==)
```

This error is happening because the `move_north` method does not change `@north` at all. Before we can change `@north`, we should properly initialize it for our robot, just like we do with the `@east` variable.

Let's change the `initialize` method for `ToyRobot::Robot` to initialize both `@east` and `@north`:

```ruby
def initialize(east = 0, north = 0)
  @east = east
  @north = north
end
```

If we were to run our tests again, we'll see that `north` is now `0` instead of `nil`:

```
Failure/Error: expect(subject.north).to eq(3)

  expected: 3
       got: 0

  (compared using ==)
```

The `north` method will forever output `0` until we make our `move_north` method actually change this value, so let's do that now so that we can have happy tests. This method should increment the value of `@north`:

```ruby
def move_north
  @north += 1
end
```

Running our tests again will show that they're happy:

```
6 examples, 0 failures
```

Excellent. We now have just one more direction to implement (`move_south`) before our robot can move in all the directions it is supposed to. Let's add a few tests for this new direction to `spec/toy_robot/robot_spec.rb`:

```ruby
it "moves 3 spaces south" do
  3.times { subject.move_south }
  expect(subject.north).to eq(-3)
end

it "moves 4 spaces south" do
  4.times { subject.move_south }
  expect(subject.north).to eq(-4)
end
```

When the robot moves south, it should decrease its `@north` position the number of times it has moved. Let's run these tests now. We'll see that the `move_south` method is missing:

```
Failure/Error: 3.times { subject.move_south }

NoMethodError:
  undefined method `move_south' for #<ToyRobot::Robot:0x007fb2b99739e8 @east=0, @north=0>
  Did you mean?  move_north
```

Now that we have some failing tests, let's add this `move_south` method to `ToyRobot::Robot` in `lib/toy_robot/robot.rb`:

```ruby
def move_south
  @north -= 1
end
```

Running the tests again will show that we've now finished implementing all 4 directions for our robot:

```
8 examples, 0 failures
```

We've now finished making our robot move. If we could see our robot moving, it would look something like this:

<center>
<svg id="table" width="250" height="250">
    <desc>Created with Snap</desc><defs></defs><line x1="20%" x2="20%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="20%" y2="20%" stroke="#000000" style="stroke-width: 2;"></line><line x1="40%" x2="40%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="40%" y2="40%" stroke="#000000" style="stroke-width: 2;"></line><line x1="60%" x2="60%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="60%" y2="60%" stroke="#000000" style="stroke-width: 2;"></line><line x1="80%" x2="80%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="80%" y2="80%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="0" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="0" y1="0" y2="100%" stroke="#000000" style="stroke-width: 10;"></line><line x1="100%" x2="100%" y1="100%" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="100%" y1="100%" y2="100%" stroke="#000000" style="stroke-width: 10;"></line>
      <path d="M125,125 H175 V175 H125 V125"
          stroke="none" stroke-width="2"
          fill="none" id="theMotionPath"/>
      <circle r="15">
        <animateMotion dur="3s" repeatCount="indefinite">
          <mpath xlink:href="#theMotionPath"/>
        </animateMotion>
      </circle>
  </svg>
</center>

We should be proud of our progress so far. We've managed to implement one of the rules for our robot:

> * MOVE will move the toy robot one unit forward in the direction it is currently facing.

Well, most of that rule. We haven't yet considered the "in the direction it is currently facing" part. We've got a pretty good base to build on at the moment (thanks a lot to our tests!), and we can very likely add in facing support with very little fuss. Thanks to the tests that we've written, we'll also be able to ensure that our robot is performing as normal just by running these tests again.

We're now tracking the north and east position of the robot, and the next thing that we need to support is the facing direction of the robot. Let's take a look at that.

## Moving in the right direction

The facing direction is important because the robot has to move _in the direction it is currently facing_, and when the robot reports it needs to be able to tell us what direction it is currently facing. Later on, we'll also need to know what direction the robot is currently facing in order to know which direction to turn to when the robot is asked to turn left or right.

We've been working on moving the robot so far, and so lets stick with that and make it so that the robot moves _in the direction its currently facing_. To start with, we're going to need to track the direction the robot is facing in a similar way to how we've been tracking the robot's north and east positions. Then based on the direction the robot is facing, it will be able to work out which direction to move in. If the robot is facing north, then a `MOVE` command should move the robot north.

Let's add a new test to `spec/toy_robot/robot_spec.rb` to test this functionality:

```ruby
context "when facing north" do
  subject { ToyRobot::Robot.new(0, 0, "NORTH") }

  it "moves north" do
    subject.move
    expect(subject.north).to eq(1)
  end
end
```

With this test, we're overriding the original `subject` with a new one, which initializes the robot at `(0, 0)` and facing `NORTH`. This test is different from the other tests in that we're only telling the robot to move. The robot should then work out that because it's facing north it should move north. The value of `north` then should be `1`, as if we had called `move_north` directly.

Let's run this test and see what happens:

```
Failure/Error:
  def initialize(east = 0, north = 0)
    @east = east
    @north = north
  end

ArgumentError:
  wrong number of arguments (given 3, expected 0..2)
```

This failure is happening because we're passing an extra argument than is expected to `initialize`: the facing direction of the robot. Let's add this argument to our `initialize` method:

```ruby
def initialize(east = 0, north = 0, direction = "NORTH")
  @east = east
  @north = north
  @direction = direction
end
```

Our robot will now have a way of tracking the direction it is pointing, defaulting to `NORTH`. There's no particular reason to default to `NORTH` over the other compass directions; it was the first direction that came to mind.

Running our test again will show that the robot doesn't know about the `move` method:

```
Failure/Error: subject.move

NoMethodError:
  undefined method `move' for #<ToyRobot::Robot:0x007fd3de0f1270>
```

This `move` method should work out what direction the robot is facing and then choose the right method out of `move_north`, `move_east`, `move_south` and `move_west`. Let's define this method in `lib/toy_robot/robot.rb` as simply as we can in order to get the test to pass now:

```ruby
def move
  move_north
end
```

Our test requires the robot to move one space north, and the `move_north` method will accomplish just that. We can verify that by running our tests again:

```
9 examples, 0 failures
```

Okay, but what happens if our robot was facing `SOUTH` instead of `NORTH`? Well, our `move` method would move the robot the wrong way! Let's write a test to cover this:

```ruby
context "when facing south" do
  subject { ToyRobot::Robot.new(0, 0, "SOUTH") }

  it "moves south" do
    subject.move
    expect(subject.north).to eq(-1)
  end
end
```

Running this test will show that indeed our robot is moving in the wrong direction:

```
Failure/Error: expect(subject.north).to eq(-1)

  expected: -1
       got: 1

  (compared using ==)
```

Our `move` method is going to have to be smarter! Let's change it so that it checks what `@direction` is before determining which method to call:

```ruby
def move
  case @direction
    when "NORTH" then move_north
    when "SOUTH" then move_south
  end
end
```

Running our tests again will now show that the robot is moving the correct direction if it is facing `SOUTH`:

```
10 examples, 0 failures
```

Great! Our robot now moves in the right direction when it's facing `NORTH` or `SOUTH`, but what happens if the robot is facing `EAST` or `WEST`? Probably nothing at this stage. We can verify what happens by expanding our tests to cover these situations. Let's add a test for the `EAST` direction:

```ruby
context "when facing east" do
  subject { ToyRobot::Robot.new(0, 0, "EAST") }

  it "moves east" do
    subject.move
    expect(subject.east).to eq(1)
  end
end
```

When we run this test, we'll see that the robot doesn't move at all:

```
Failure/Error: expect(subject.east).to eq(1)

  expected: 1
       got: 0

  (compared using ==)
```

The robot doesn't understand what `move` means when its facing `EAST` because we haven't told it. The `move` method is only implemented in such a way that the robot understands what to do when it's facing `NORTH` or `SOUTH`:

```ruby
def move
  case @direction
    when "NORTH" then move_north
    when "SOUTH" then move_south
  end
end
```

Let's add a line here so that the robot knows what to do when it is facing `EAST`:

```ruby
def move
  case @direction
    when "NORTH" then move_north
    when "SOUTH" then move_south
    when "EAST"  then move_east
  end
end
```

Running our tests will now show that this latest test is now passing:

```
11 examples, 0 failures
```

We can probably guess here that when the robot is facing `WEST` and it's asked to move that it isn't going to move, but let's follow protocol and write a test to verify that misbehaviour:

```ruby
context "when facing west" do
  subject { ToyRobot::Robot.new(0, 0, "WEST") }

  it "moves west" do
    subject.move
    expect(subject.east).to eq(-1)
  end
end
```

Running this test will indeed show that the robot doesn't know what to do when its asked to move when facing `WEST`:

```
Failure/Error: expect(subject.east).to eq(-1)

  expected: -1
       got: 0

  (compared using ==)
```

Let's add one more line to the `move` method again to make this test work:

```ruby
def move
  case @direction
    when "NORTH" then move_north
    when "SOUTH" then move_south
    when "EAST"  then move_east
    when "WEST"  then move_west
  end
end
```

One more run of the tests will show that they're all working again:

```
12 examples, 0 failures
```

Our robot now understands what to do once it's facing any direction. However, there is a way that we can tidy up the `move` method. In that method we're always calling a method beginning with `move_` and ending with the direction that the robot is facing. We can use a little bit of metaprogramming here to shorten the method:

```ruby
def move
  send("move_#{@direction.downcase}")
end
```

By using `send` here, we're getting the robot to decide for itself when it receives a `move` instruction which `move_*` method to call, based on the downcased (lowercased) `@direction`. This makes our method much shorter, but comes at the cost of easier readability. I think it's a worthwhile sacrifice to do here, but we should be careful not to rely on metaprogramming too much. Code that uses metaprogramming is not always the best code and can be hard to debug when we come back to it weeks or months later.

We should run our tests again to verify that the robot is still behaving the ways that we expect it to:

```
12 examples, 0 failures
```

Yes, it is indeed behaving correctly.

What we've now done is implemented the first command for our robot completely: the `MOVE` command. The robot will now move in the direction it is currently facing when it is asked to move.

What we've also done is provided a wonderful framework in the `ToyRobot::Robot` class to add additional functionality to, and we have an extensive test suite which ensures that our robot will always work the way that we want it to. Thanks to this framework and test suite combination, adding more features will be very easy.

Our robot can now move and report its north and east position, as well as the direction it's facing. This means that we've satisifed _two_ of the commands that we want to:

> * MOVE will move the toy robot one unit forward in the direction it is currently facing.
> * REPORT announces the X,Y and F of the robot.

We have a way to move the robot one unit forward in the direction it's facing through our `move` method. We have a way to report the `x` and `y` (which we've called `east` and `north`) and `F` or `facing` of the robot, by calling the `east`, `north` and `facing` methods on a robot, provided by the `attr_reader`.

Out of the commands to be processed, we have these two left:

> * PLACE will put the toy robot on the table in position X,Y and facing NORTH, SOUTH, EAST or WEST.
> * LEFT and RIGHT rotates the robot 90 degrees in the specified direction without changing the position of the robot.

We don't yet have a concept of a table, and so we can ignore `PLACE` for now. Let's look at making our robot obey the `LEFT` and `RIGHT` commands.

## Turn left!

Our robot has a concept of the direction it is facing in the `@direction` variable, but it doesn't know how to change that variable to a different value once it has been set. This is what will be required if our robot is to understand what `left` and `right` are.

The initial description of our problem says this about the `LEFT` and `RIGHT` commands:

> * LEFT and RIGHT rotates the robot 90 degrees in the specified direction without changing the position of the robot.

We _would_ go ahead and track the degrees the robot is facing, but the `PLACE` command says this:

> * PLACE will put the toy robot on the table in position X,Y and facing NORTH, SOUTH, EAST or WEST.

We know that `WEST` is 90 degrees anti-clockwise from `NORTH`, and `EAST` is 90 degrees clockwise and so we can simply track which direction out of `NORTH`, `SOUTH`, `EAST` or `WEST` the robot is facing, rather than the degrees.

Let's start off by just implementing the `left` method for our robot, so that it can turn left to face a new heading. We'll write a test for this inside the `"when facing north"` context block that we defined earlier:

```ruby
context "when facing north" do
  subject { ToyRobot::Robot.new(0, 0, "NORTH") }

  it "moves north" do
    subject.move
    expect(subject.north).to eq(1)
  end

  it "turns left to face west" do
    subject.left
    expect(subject.direction).to eq("WEST")
  end
end
```

When we run this test it will fail because our robot knows nothing about the `left` method:

```
Failure/Error: subject.left

NoMethodError:
  undefined method `left' for #<ToyRobot::Robot:...>
```

How are we to implement this `left` method? Well, we know that our robot is currently facing `NORTH`, and that we want it to end up facing `WEST`. That's the info that we have in our test. If our robot had a little device indicating its direction that we could look at, it might look something like this:

<center>
<svg width="400" height="400">
  <circle r="190" cx="50%" cy="50%" fill="none" stroke="black" stroke-width="3" />
  <circle r="110" cx="50%" cy="50%" fill="none" stroke="black" stroke-width="2" />
  <defs>
    <marker id="Triangle" viewBox="0 0 10 10" refX="1" refY="5"
        markerWidth="6" markerHeight="6" orient="auto">
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
  </defs>
    <polyline points="200,250 200,175" fill="none" stroke="black"
        stroke-width="7" marker-end="url(#Triangle)" />
    <text x="47%" y="15%" font-size="24pt" font-family="Titillium Web">N</text>
    <text x="10%" y="52%" font-size="24pt" font-family="Titillium Web">W</text>
    <text x="85%" y="52%" font-size="24pt" font-family="Titillium Web">E</text>
    <text x="48%" y="90%" font-size="24pt" font-family="Titillium Web">S</text>
</svg>
</center>

We want that arrow in the middle to spin to the left and to point to "W" (`WEST`). We could come up with some complex code that will satisify all direcitons, but there is a very easy way that we can satisify our tests: set the direction of the robot to `WEST` whenever `left` is called:

```ruby
def left
  @direction = "WEST"
end
```

Running our tests again will show that they're all happy:

```
13 examples, 0 failures
```

We've done the absolute bare minimum to get our test to pass yet again. We're not writing bad tests, we're just writing simple ones. Let's write another simple test to test what happens when the robot is facing `SOUTH` instead of `NORTH` and it's asked to turn left:

```ruby
context "when facing south" do
  subject { ToyRobot::Robot.new(0, 0, "SOUTH") }

  it "moves south" do
    subject.move
    expect(subject.north).to eq(-1)
  end

  it "turns left to face east" do
    subject.left
    expect(subject.direction).to eq("EAST")
  end
end
```

In this test, we're asserting that if our robot is facing `SOUTH` and asked to turn left, then its new direction will be `EAST`. Running this test will show that the robot receives the instruction loud and clear, but instead it faces `WEST`:

```
Failure/Error: expect(subject.direction).to eq("EAST")

  expected: "EAST"
       got: "WEST"

  (compared using ==)
```

This is because our robot will _always_ face `WEST` when it receives a `left` call. It's a good thing that we wrote another test for `left` so that we have now confirmed the robot's bad behaviour. The `left` method is now going to have to be smarter!

We can change the `left` method to be smarter by changing it to this:

```ruby
def left
  @direction = case @direction
    when "NORTH" then "WEST"
    when "SOUTH" then "EAST"
  end
end
```

If you remember back to the way we initially wrote the `move` method, this new `left` method looks similar:

```ruby
def move
  case @direction
    when "NORTH" then move_north
    when "SOUTH" then move_south
  end
end
```

The difference is though that we don't have the same repetition here. `NORTH` becomes `WEST` in the `left` method, rather than `NORTH` meaning "move north". If we were able to tidy up `move`, we may be able to tidy up `left` in a similar way too. That's just something to keep in mind for later.

For now, let's see if our test is passing:

```
14 examples, 0 failures
```

Great! Our Robot now knows that if it's facing `SOUTH` and its asked to turn `left` then it will update its direction to face `EAST`.

Let's add two more quick tests here for the two remaining compass directions: `EAST` and `WEST`:

```ruby
context "when facing east" do
  subject { ToyRobot::Robot.new(0, 0, "EAST") }

  ...

  it "turns left to face north" do
    subject.left
    expect(subject.direction).to eq("NORTH")
  end
end

context "when facing west" do
  subject { ToyRobot::Robot.new(0, 0, "WEST") }

  ...

  it "turns left to face south" do
    subject.left
    expect(subject.direction).to eq("SOUTH")
  end
end
```

When we run these tests, we'll see that our robot doesn't know what to do:

```
Failure/Error: expect(subject.direction).to eq("NORTH")

  expected: "NORTH"
       got: nil

  (compared using ==)

...

Failure/Error: expect(subject.direction).to eq("SOUTH")

  expected: "SOUTH"
       got: nil

  (compared using ==)
```

This is because we've only told it what to do in the case it is facing `NORTH` or `SOUTH`. Let's update `left` to support all four compass directions:

```ruby
def left
  @direction = case @direction
    when "NORTH" then "WEST"
    when "WEST" then "SOUTH"
    when "SOUTH" then "EAST"
    when "EAST" then "NORTH"
  end
end
```

Running the tests once more will show that our robot now understands what to do when it's asked to turn left from any compass direction:

```
16 examples, 0 failures
```

Excellent! We've written some tests that assert the behaviour of the robot is correct and then we've written some code to make those tests pass. With that all done, can we find out a way to shorten the `left` method?

We don't really need to shorten this method -- it does what we want it to do in just 6 lines of code -- but this is a good practice to think this way before continuing. You may write a method that spans tens of lines to make the test pass, and then look at the method again and find a way to write it shorter or simpler.

In the case of our `left` method, the `case` statement doesn't have any obvious way of writing it shorter. There's no repetition in it that we could condense in a similar way to what we did in the `move` method. What there is though is a kind of circular logic about it. This is because what we've implemented here is effectively a rotating dial, but in code form. Let's look at our compass again:

<center>
<svg width="400" height="400">
  <circle r="190" cx="50%" cy="50%" fill="none" stroke="black" stroke-width="3" />
  <circle r="110" cx="50%" cy="50%" fill="none" stroke="black" stroke-width="2" />
  <defs>
    <marker id="Triangle" viewBox="0 0 10 10" refX="1" refY="5"
        markerWidth="6" markerHeight="6" orient="auto">
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
  </defs>
    <polyline points="200,250 200,175" fill="none" stroke="black"
        stroke-width="7" marker-end="url(#Triangle)" />
    <text x="47%" y="15%" font-size="24pt" font-family="Titillium Web">N</text>
    <text x="10%" y="52%" font-size="24pt" font-family="Titillium Web">W</text>
    <text x="85%" y="52%" font-size="24pt" font-family="Titillium Web">E</text>
    <text x="48%" y="90%" font-size="24pt" font-family="Titillium Web">S</text>
</svg>
</center>

If we were to turn this dial into a list of the directions, going clockwise, like this:

```ruby
directions = ["NORTH", "EAST", "SOUTH", "WEST"]
```

How would we then tell the robot to turn left or right? If the robot was at `NORTH` and we wanted to turn right, then the robot should then be facing `EAST`. If the robot was at `NORTH` and we turned left, then the robot should then be facing `WEST`. In both cases, we're moving backwards or forwards along the array by one element: `EAST` is one element to the "right" of `NORTH` and with a bit of imagination, `WEST` is one element to the "left" of `NORTH`.

Using the above code, we would need to first find out the position of the current direction in the array to then know which direction we should move to. To do that, we can use `index`:

```ruby
directions = ["NORTH", "EAST", "SOUTH", "WEST"]
directions.index("NORTH")
# => "0"
```

This returns `0` as `NORTH` is the 0th element in the array. To change the direction to `EAST`, we would need to get to the 1st element of the array: `EAST`. We can do that by adding 1 to our index and using that to look up the direction:

```
directions = ["NORTH", "EAST", "SOUTH", "WEST"]
directions[directions.index("NORTH") + 1]
# => "EAST"
```

Here we're using the `index` of `NORTH` in the array, which is `0` and then we're adding 1 to that. The code then effectively becomes `directions[1]`, which returns `EAST`.

But that's turning `RIGHT` and we've been currently focussing on turning `LEFT`. How would we do this to turn left? We can simply minus 1 from the index:

```
directions = ["NORTH", "EAST", "SOUTH", "WEST"]
directions[directions.index("NORTH") - 1]
# => "WEST"
```

This should be good enough for us to implement turning in our robot, so let's try replacing the `left` method's code with this:

```ruby
def left
  @direction = DIRECTIONS[DIRECTIONS.index(@direction) - 1]
end
```

We'll define the `DIRECTIONS` constant at the top of our `ToyRobot` class:

```ruby
module ToyRobot
  class Robot
    DIRECTIONS = ["NORTH", "EAST", "SOUTH", "WEST"]
    ...
```

We've done this so that we can use it in both the `left` and `right` method; once we get around to writing the `right` method that is.

Does this change to the `left` method still satisfy our tests? Let's run them and find out:

```
16 examples, 0 failures
```

Yes, it does. Our code is now a single line, but it sacrifices some readability. I think this is a better way to do it because the directions are not hardcoded here.

Our robot is now able to turn left from any direction it is facing, as evidenced by our tests all being green. Let's take a look at making our robot turn right now.

## Turn right!

To make sure our robot will behave when it is asked to turn right, we should write some tests. Let's start with just two tests, one for when the robot is currently facing `NORTH` and one for when it is facing `SOUTH`:

```ruby
context "when facing north" do
  subject { ToyRobot::Robot.new(0, 0, "NORTH") }

  ...

  it "turns right to face east" do
    subject.right
    expect(subject.direction).to eq("EAST")
  end
end

context "when facing south" do
  subject { ToyRobot::Robot.new(0, 0, "SOUTH") }

  ...

  it "turns right to face west" do
    subject.right
    expect(subject.direction).to eq("WEST")
  end
end
```

These two tests assert tha when the robot is asked to turn right when it's facing `NORTH` it will then face `EAST`, and if the robot is facing `SOUTH` then it will end up facing `WEST`. Let's run these two tests and see what happens. Both of our tests will show this:

```
Failure/Error: subject.right

NoMethodError:
  undefined method `right' for #<ToyRobot::Robot:...>
```

We should've (and might've) seen that this was going to happen. Let's go ahead and define this `right` method in our `ToyRobot::Robot` class.

```
def right
  @direction = DIRECTIONS[DIRECTIONS.index(@direction) + 1]
end
```

The `left` method takes the current direction's index and minuses 1 to get the new direction, and so it only makes sense for us to go the opposite direction when we're turning opposite. Running the tests will now show that they're working:

```
18 examples, 0 failures
```

This is some quick progress we're making. It's quick because we've got a good framework setup for adding in and testing new functionality for our robot. Let's look at adding some tests for the two remaining directions (`EAST` and `WEST`):

```ruby
context "when facing east" do
  subject { ToyRobot::Robot.new(0, 0, "EAST") }

  ...

  it "turns right to face south" do
    subject.right
    expect(subject.direction).to eq("SOUTH")
  end
end

context "when facing west" do
  subject { ToyRobot::Robot.new(0, 0, "WEST") }

  ...

  it "turns right to face north" do
    subject.right
    expect(subject.direction).to eq("NORTH")
  end
end
```

Our tests for turning right when facing `NORTH` and `SOUTH` ran successfully, so there should be no reason why these two new tests will not pass either. Let's run them and see if they do indeed pass:

```
Failure/Error: expect(subject.direction).to eq("NORTH")

  expected: "NORTH"
       got: nil

  (compared using ==)
```

Oh no! One of our tests is failing. When the robot faces `WEST` and is asked to turn `RIGHT`, it instead turns to face `nil`. This is obviously not right and a great example of why we should be testing our robot's behaviour.

Let's walk through what's happening here to cause this test to fail. We'll start by taking a long hard look at our `right` method:

```ruby
def right
  @direction = DIRECTIONS[DIRECTIONS.index(@direction) + 1]
end
```

This method takes the current direction, passes it to `DIRECTIONS.index`. This gets the current direction's position in the `DIRECTIONS` array. It then adds 1 to this list. Walking through this code, this is the process it will go through:

```ruby
DIRECTIONS = ["NORTH", "EAST", "SOUTH", "WEST"]
DIRECTIONS.index("WEST") # => 3
DIRECTIONS[3 + 1] # => nil
```

There is no 4th element in this array, which is why it is returning `nil`. Our code has been smart enough know that when we ask the robot to turn left from `NORTH`, it will take the current index and minus 1, which ends up doing `DIRECTIONS[-1]`. This will find the _last_ element in the `DIRECTIONS` array. However, there is no such helpfulness to be found in Ruby when we try to access an element at an index which isn't in the array.

We must come up with an alternative solution if we want our robot to be able to turn right successfully, no matter the direction it is facing.

The `rotate` method for `Array` will come in handy here. We can rotate the array, just like we would rotate the compass:

```ruby
def right
  index = DIRECTIONS.index(@direction)
  @direction = DIRECTIONS.rotate(1)[index]
end
```

In this new take on the method, we still take the index of the current position, but then we use it on a rotated version of our `DIRECTIONS` array. Calling `DIRECTIONS.rotate(1)` here will turn our `DIRECTIONS` into:

```
["EAST", "SOUTH", "WEST", "NORTH"]
```

In this case of this test, we've got the robot starting facing `WEST`. The index of this direction in the original `DIRECTIONS` array is `3`. Calling `rotate(1)` on `DIRECTIONS` and then finding the new element at the same index will return `NORTH`, as that is now the element which is at the 3rd position in the array.

Running our test again will show that the `right` method's changes worked to fix the broken test:

```
20 examples, 0 failures
```

The issue is now that our `left` and `right` commands have two separate implementations of very similar behaviour. We can standardise this behaviour into a single method that can be shared between `left` and `right`.

Let's define a new method called `turn` underneath a `private` keyword at the bottom of the `ToyRobot::Robot` class:

```ruby
private

def turn(turn_direction)
  index = DIRECTIONS.index(@direction)
  rotations = turn_direction == :right ? 1 : -1
  @direction = DIRECTIONS.rotate(rotations)[index]
end
```

This method is almost identical to our `right` method, except that it takes an argument called `turn_direction`. This argument will be checked to see if it's `:right`, and if it is then the array is rotated right; otherwise it is rotated left. We can then use the same method regardless of the direction to find what new direction the robot is facing given that rotation.

We can change our `left` and `right` methods to use this new `turn` method, further simplifying their code:

```ruby
def left
  turn(:left)
end

def right
  turn(:right)
end
```

We can change these methods fearlessly because we have rigourous tests which test the behavour of the methods. If we want to make sure these methods work after the change, we have only to run the tests. Speaking of them, let's run them now:

```
20 examples, 0 failures
```

Our tests are still all passing. This is great to see!

Our robot can now move in the direction it is currently facing and responds to calls to turn left or right. We've now fully implemented these two commands of our robot:

> * MOVE will move the toy robot one unit forward in the direction it is currently facing.
> * LEFT and RIGHT rotates the robot 90 degrees in the specified direction without changing the position of the robot.

We now have two commands left to implement:

> * REPORT announces the X,Y and F of the robot.
> * PLACE will put the toy robot on the table in position X,Y and facing NORTH, SOUTH, EAST or WEST.

The great news is that we already have the features in our robot to build both of these commands very easily.

Let's start with `REPORT`.

## The `REPORT` command

The `REPORT` command's description says:

> * REPORT announces the X,Y and F of the robot.

We already have the `X`, `Y` and `F` of the robot in our `@north`, `@east` and `@direction` variables, and so getting the robot to report is just a matter of making a method that returns all of these variables.

Let's add a new test for this `report` method to the bottom of `spec/toy_robot/robot_spec.rb`:

```ruby
context "#report" do
  subject { ToyRobot::Robot.new(5, 4, "EAST") }

  it "provides the current location and direction of the robot" do
    expect(subject.report).to eq({
      north: 5,
      east: 4,
      direction: "EAST"
    })
  end
end
```

This test is asserting that the `report` method exposes the variables for the location and direction of the robot as a `Hash`. Running this test will show that the `report` method isn't defined:

```ruby
Failure/Error:
  expect(subject.report).to eq({
    north: 5,
    east: 4,
    direction: "EAST"
  })

NoMethodError:
  undefined method `report' for #<ToyRobot::Robot:...>
```

Let's go about defining it then to make our test happy. Back over in `ToyRobot::Robot`, we'll add this:

```ruby
def report
  {
    north: @north,
    east: @east,
    direction: @direction
  }
end
```

Could it really be that easy? Let's find out by running our tests:

```
21 examples, 0 failures
```

Yes, indeed it can be that easy. Supporting this command was by far the easiest so far, because the command is simple compared with the other commands; it just needs to report.

Let's move onto the `PLACE` command.

## The `PLACE` command

The `PLACE` command's description says this:

> * PLACE will put the toy robot on the table in position X,Y and facing NORTH, SOUTH, EAST or WEST.

However, there's another two clues to what this command should do hidden in the description:

> Any movement that would result in the robot falling from the table is prevented

And:

> The application is a simulation of a toy robot moving on a square tabletop, of dimensions 5 units x 5 units.

So an invalid `PLACE` command would be anything that was outside the boundaries of the _"5 units by 5 units"_ of the table top. For instance, if the robot was placed at `(6, 7)`, it would be invalid because the robot is outside the boundaries of the table.

To write this `place` command correctly we're going to need to know about the table boundaries. Those boundaries shouldn't be something that the robot knows about, because the robot is only meant to move inside those boundaries. It is now the time to create two new classes -- which we'll call `ToyRobot::Table` and `ToyRobot::Simulator`.

`ToyRobot::Table` will be responsible for knowing the dimensions of the table and responding to questions about whether a particular location is a valid location for the robot to be placed at or for the robot to move to.

`ToyRobot::Simulator` -- which will rely on both the `ToyRobot::Robot` and `ToyRobot::Table` classes -- will handle the `PLACE` command. It will first check the `ToyRobot::Table` class to see if the placement of the robot is within the correct boundaries, and then if it is it will initialize a new robot using the `ToyRobot::Robot` class.

Later on when we are reading the commands from a file, we'll be sending those commands to our robot through the `ToyRobot::Simulator` class.

Before we get there though, let's focus on the `ToyRobot::Table` class.

### Creating the table class

The `ToyRobot::Table` class will know the dimensions of a table and will provide a method to let us know if a particular placement is valid or invalid. A placement can be invalid because, as we just saw:

> Any movement that would result in the robot falling from the table is prevented

We'll be using this method -- which we'll call `valid_location?` -- in our `ToyRobot::Simulator` class later to determine if we should follow a `PLACE` or `MOVE` command. If the location specified is not valid, then our simulator should ignore that command.

Let's write some tests for our new `valid_location?` method in a new file called `spec/toy_robot/table_spec.rb`:

```ruby
require 'spec_helper'

describe ToyRobot::Table do
  subject { ToyRobot::Table.new(5, 5) }

  context "valid_location?" do
    it { should be_valid_location(0, 0) }
    it { should be_valid_location(4, 4) }
    it { should_not be_valid_location(5, 5) }
    it { should_not be_valid_location(-1, -1) }
  end
end
```

With this new test, we're building a new table that is 5 by 5. We then have three quick assertions: that the locations `(0, 0)` and `(5, 5)` are valid, and the locations `(6, 6)` and `(-1, -1)` are invalid.

Running this test will show us that the `ToyRobot::Table` class isn't yet initialized:

```
spec/toy_robot/table_spec.rb:3:in `<top (required)>':
  uninitialized constant ToyRobot::Table (NameError)
```

We will need to follow the same steps that we did for the `ToyRobot::Robot` class all that time ago. The two steps are:

* Define the constant in a file called `lib/toy_robot/table.rb`.
* Require this file in `lib/toy_robot.rb`.

Let's define that constant now in `lib/toy_robot/table.rb`:

```ruby
module ToyRobot
  class Table

  end
end
```

And we'll require this new file in `lib/toy_robot.rb` so that the constant is available in our tests:

```
require "toy_robot/version"
require "toy_robot/robot"
require "toy_robot/table"

module ToyRobot
  # Your code goes here...
end
```

When we run the test again, we'll see that the constant is now defined, but the test is now complaining that we're passing the wrong number of arguments through to `new`:

```
Failure/Error: subject { ToyRobot::Table.new(5, 5) }

ArgumentError:
  wrong number of arguments (given 2, expected 0)
```

We will need to define an `initialize` method which takes two arguments inside of `ToyRobot::Table` to satisfy our test:

```ruby
module ToyRobot
  class Table
    def initialize(width, length)
      @width = width
      @length = length
    end
  end
end
```

This new method stores the two arguments passed in through `new` as `@width` and `@length`. We'll be using these to validate locations in a moment. Let's first see how our tests are going:

```ruby
Failure/Error: it { should_not be_valid_location(-1, -1) }
  expected #<ToyRobot::Table:... @width=5, @length=5> to respond to `valid_location?`
```

Our tests are now expecting there to be a `valid_location?` method, but since there isn't one, they are failing. Let's add a blank one in to the `ToyRobot::Table` class. This method will need to take two arguments too:

```ruby
module ToyRobot
  class Table
    def initialize(width, length)
      @width = width
      @length = length
    end

    def valid_location?(north, east)

    end
  end
end
```

Running the test one more time will show that it now accepts that the `valid_location?` method is there, and that the method is not performing as intended:

```
Failure/Error: it { should be_valid_location(5, 5) }
  expected `#<ToyRobot::Table:0x007fc493935670 @width=5, @length=5>.valid_location?(5, 5)` to return true, got nil
```

The `valid_location?` method needs to take a `north` and `east` argument, and then check to see if that given position is a valid location on the table. We'll be assuming that the bottom left (south western) edge of the table is `(0, 0)`, as that is what our problem description says to do:

> * The origin (0,0) is the SOUTH WEST most corner.

With that in mind, a table that's 5 units by 5 units will look like this:
<center>
<svg id="table" width="250" height="250">
    <desc>Created with Snap</desc><defs></defs><line x1="20%" x2="20%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="20%" y2="20%" stroke="#000000" style="stroke-width: 2;"></line><line x1="40%" x2="40%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="40%" y2="40%" stroke="#000000" style="stroke-width: 2;"></line><line x1="60%" x2="60%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="60%" y2="60%" stroke="#000000" style="stroke-width: 2;"></line><line x1="80%" x2="80%" y1="0" y2="100%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="80%" y2="80%" stroke="#000000" style="stroke-width: 2;"></line><line x1="0" x2="100%" y1="0" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="0" y1="0" y2="100%" stroke="#000000" style="stroke-width: 10;"></line><line x1="100%" x2="100%" y1="100%" y2="0" stroke="#000000" style="stroke-width: 10;"></line><line x1="0" x2="100%" y1="100%" y2="100%" stroke="#000000" style="stroke-width: 10;"></line>
    <text x="5%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 0)
    </text>
    <text x="25%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 1)
    </text>
    <text x="45%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 2)
    </text>
    <text x="65%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 3)
    </text>
    <text x="85%" y="13%" font-family="Titillium Web" font-size="12">
    (4, 4)
    </text>
    <text x="5%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 0)
    </text>
    <text x="25%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 1)
    </text>
    <text x="45%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 2)
    </text>
    <text x="65%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 3)
    </text>
    <text x="85%" y="32%" font-family="Titillium Web" font-size="12">
    (3, 4)
    </text>
    <text x="5%" y="51%" font-family="Titillium Web" font-size="12">
    (2, 0)
    </text>
    <text x="25%" y="51%" font-family="Titillium Web" font-size="12">
    (2, 1)
    </text>
    <text x="45%" y="51%" font-family="Titillium Web" font-size="12">
    (2, 2)
    </text>
    <text x="65%" y="51%" font-family="Titillium Web" font-size="12">
    (2, 3)
    </text>
    <text x="85%" y="51%" font-family="Titillium Web" font-size="12">
    (2, 4)
    </text>
    <text x="5%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 0)
    </text>
    <text x="25%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 1)
    </text>
    <text x="45%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 2)
    </text>
    <text x="65%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 3)
    </text>
    <text x="85%" y="72%" font-family="Titillium Web" font-size="12">
    (1, 4)
    </text>
    <text x="5%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 0)
    </text>
    <text x="25%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 1)
    </text>
    <text x="45%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 2)
    </text>
    <text x="65%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 3)
    </text>
    <text x="85%" y="92%" font-family="Titillium Web" font-size="12">
    (0, 4)
    </text>
   </svg>
</center>

We can see here if the coordinates given are any negative value (such as `(-1, -1)`) then they would be invalid. We can also see that if the `north` or `east` are equal to either the given width or length of the table, then the location would also be invalid; such as coordinates like `(5, 5)`. On the above table as long as both `north` and `east` are somewhere in the range of 0 to 4, then the location is valid.

Essentially, `north` and `east` both must be greater than or equal to 0, and less than the `length` or `width` of the table. With that in mind, let's have a go at implementing our `valid_location?` method:

```ruby
def valid_location?(north, east)
  east >= 0 && east < @width &&
  north >= 0 && north < @length
end
```

This method is the above logic in code form. It contains four checks which will be used to determine if the location is valid. Let's see if our logic satisfies our tests:

```
25 examples, 0 failures
```

Yes, it does. But can we write it a little neater? Yes, we can write it neater by using the triple-dot `Range` separator and only two checks:

```ruby
def valid_location?(north, east)
  (0...@width).include?(east) &&
  (0...@length).include?(north)
end
```

The triple-dot separator here will exclude the value at the end of the range. While `0..5` will be all the numbers from 0 to 5, `0...5` will be all the numbers from 0 to 4. Very handy for our `valid_location?` method! We can then check to see if the `east` and `north` coordinates are within these ranges and if they both are then the location will be considered valid.

Let's see if our all our tests still work:

```
25 examples, 0 failures
```

Indeed they do! We've now got this `ToyRobot::Table` class which can tell us if a given location is valid or not. Now we just need to use it. That's a job for our soon-to-be-created `ToyRobot::Simulator` class.

### Creating the Simulator class

We'll now create the `Simulator` class which will be responsible for managing the simulation of our toy robot. This class will receive commands and then decide what to do with them. We'll start with the `PLACE` command, as our simulator can't do much with the robot if it hasn't been placed first.

The simulator should only obey `PLACE` commands which are valid according to the table because that's what the rules say:

> * Any movement that would result in the robot falling from the table is prevented,

Let's write a new test for what happens when a robot is placed into valid and invalid positions on the table through the simulator:

```ruby
require "spec_helper"

describe ToyRobot::Simulator do
  let(:table) { ToyRobot::Table.new(5, 5) }
  subject { ToyRobot::Simulator.new(table) }

  it "places the robot onto a valid position" do
    subject.place(0, 0, "NORTH")
    expect(ToyRobot::Robot).to receive(:new)
      .with(0, 0, "NORTH")
      .and_return(double)
    expect(subject.robot).not_to be_nil
  end

  it "cannot place the robot onto an invalid position" do
    subject.place(5, 5, "NORTH")
    expect(ToyRobot::Robot).not_to receive(:new)
    expect(subject.robot).to be_nil
  end
end
```

With these tests, we're asserting that if the robot is placed in a valid location, then the simulator should have `robot` set. We're also asserting that `ToyRobot::Robot.new` is called or not called, depending on if the location is valid.

If the location is invalid, then `ToyRobot::Robot.new` should not be called at all and `robot` should not be set. We'll be using this `robot` method later on to determine if the simulator should follow commands or ignore them. We need to ignore the commands if a valid `PLACE` hasn't happened yet because our problem description says so:

> * All commands are ignored until a valid PLACE is made.

Running these new tests will show that the `Simulator` class isn't defined:

```
spec/toy_robot/simulator_spec.rb:3:in `<top (required)>':
  uninitialized constant ToyRobot::Simulator (NameError)
```

We know what to do here, so let's do it. We'll define this new class in `lib/toy_robot/simulator.rb`:

```ruby
module ToyRobot
  class Simulator

  end
end
```

Then we'll require this file in `lib/toy_robot.rb`:

```ruby
require "toy_robot/version"
require "toy_robot/robot"
require "toy_robot/table"
require "toy_robot/simulator"
```

Running the test one more time will show us that calling `new` on `Simulator` doesn't work, because the `initialize` method for that class doesn't take any arguments:

```
Failure/Error: subject { ToyRobot::Simulator.new(table) }

ArgumentError:
  wrong number of arguments (given 1, expected 0)
# ./spec/toy_robot/simulator_spec.rb:5:in `initialize'
```

Let's define this `initialize` method in the `ToyRobot::Simulator` class now:

```ruby
def initialize(table)
  @table = table
end
```

Instances of `Simulator` need to know about the `Table` instance that they're running a simulation for, because this is what the `Simulator` instances will use for determining if a `place` command is valid.

Running our test once more will show us that the `place` method is missing:

```
Failure/Error: subject.place(5, 5, "NORTH")

NoMethodError:
  undefined method `place' for #<ToyRobot::Simulator:0x007fe9c5847608>
```

We are now at the meat of our test. This `place` method must set `robot` on the `Simulator` instance, but only if the location that the robot is being placed at is valid. Let's write this method:

```ruby
def place(north, east, facing)
  return unless @table.valid_location?(north, east)

  @robot = Robot.new(north, east, facing)
end
```

We first check to see if the placement location is valid by referring to the `@table` instance. If it is, then we set `@robot` by initializing a new instance of the `Robot` class.

Looks good, but is this enough to satisfy our test? Let's find out:

```
Failure/Error: expect(subject.robot).to be_nil

NoMethodError:
  undefined method `robot' for #<ToyRobot::Simulator:...>
```

Not quite! The simulator doesn't respond to the `robot` method yet. Let's define an `attr_reader` at the top of the `Simulator` class to make it do that:

```ruby
module ToyRobot
  class Simulator
    attr_reader :robot
```

Another run of the tests will show that everything is as it should be:

```
27 examples, 0 failures
```

Hooray! Our simulator will now know how to obey a place command once the simulator receives it.

We've now implemented _most_ of what the problem description asks for. Our robot can move, turn, report and be placed. The part that we haven't implemented yet is the actual command reading:

> * The application reads a file using a name passed in the command line

Once we complete this part, then we can connect our code together and we will have a complete implementation of the toy robot.

## Reading commands

We've now reached the part where we're going to read commands in from a file. From our problem description, this file looks something like this:

```
PLACE X,Y,F
MOVE
LEFT
RIGHT
REPORT
```

What we're going to need to process this file is another class which will interpret each line from this file into something the `Simulator` class can understand. The `Simulator` class will then receive these commands and issue them to the robot.

This new class responsible for command processing will turn a `PLACE X,Y,F` command from the file into an `Array` of `[:place, x, y, f]`. Similarly, it will turn a `MOVE` command into just `[:move]`. If this new class receives an invalid command, it will return `[:invalid, "INVALID COMMAND GOES HERE"]`. We can then process the output of this new class in the `Simulator` class through some fancy Ruby like this:

```ruby
command_method, *args = command
```

In the case of a `PLACE X,Y,F` command being turned into `[:place, x, y, f]`, the above code will set `command_method` to `:place`, and then the `args` variable will be set to `[x, y, f]`. In the `Simulator` class, we can then make a call to this method using `send`, like this:

```ruby
send(command_method, *args)
```

This will call the `place` method with the specified arguments. Our `Simulator` only supports `place` for now, but it will support the other commands too.

So here's what we'll do: we'll work on our `Command` class and ensure it can parse all the separate commands. Then we'll look at reading an example file using this new class. Then we'll ensure that the `Simulator` instances can respond to these commands and that it tells the robot to move, turn left, turn right or report.

Let's start out by writing a test for what happens when this `Command` class processes a valid `PLACE` command. We'll write this test in `spec/toy_robot/command_spec.rb`:

```ruby
require 'spec_helper'

describe ToyRobot::Command do
  context "PLACE" do
    it "processes a PLACE command" do
      command, *args = ToyRobot::Command.process("PLACE 1,2,NORTH")
      expect(command).to eq(:place)
      expect(args).to eq([1, 2, "NORTH"])
    end
  end
end
```

As before with all other constants under `ToyRobot`, we're going to need to define the `Command` constant. Let's do that now in a new file at `lib/toy_robot/command.rb`:

```ruby
module ToyRobot
  class Command

  end
end
```

We'll then require this file in `lib/toy_robot.rb`:

```ruby
require "toy_robot/version"
require "toy_robot/robot"
require "toy_robot/table"
require "toy_robot/simulator"
require "toy_robot/command"
```

With that done, when we run this test we'll see that the `process` method is missing from the `ToyRobot::Command` class:

```
Failure/Error: command, *args = ToyRobot::Command.process("PLACE 1,2,NORTH")

NoMethodError:
  undefined method `process' for ToyRobot::Command:Class
```

This method needs to return an array of `[:place, 1, 2, "NORTH"]` to satisfy our test. Let's write this `process` method in the `ToyRobot::Command` class now.

```ruby
module ToyRobot
  class Command
    def self.process(command)
      /\APLACE (\d+),(\d+),(\w+)\Z/ =~ command
      [:place, $1.to_i, $2.to_i, $3]
    end
  end
end
```

To match our `PLACE` command's particular syntax, we can use a regular expression. This regular expression will match only `PLACE` commands formatted like `PLACE X,Y,F`. This won't match `PLACE X, Y, F` because our problem description says this:

>  It is assumed that the PLACE command has only one space, that is PLACE 1, 2, NORTH is an invalid command. All commands must be in upcase, all lower and mixed case commands will be ignored.

We use the regular expression match operator (`=~`) here to match the regular expression to the incoming command. The `\A` at the beginning and `\Z` at the end of the regular expression match the beginning and end of a string.

<aside>
  <strong>Note</strong>: You can use <a href='http://rubular.com'>Rubular.com</a> as a great site to test out Ruby regular expressions, such as the one we've just used here.
</aside>

We use _capture groups_ on the regular expression to pull out the values that we need, with each capture group being available as a variable such as `$1`. The first two groups must be converted into integers so that when a `place` happens in the simulator, the robot will be initialized with integers rather than strings. This is important because our Robot will attempt to call `@north += 1` on the values passed in here, and that will only work on numbers.

The third capture group doesn't need any such conversion, and so we can leave it as is.

Is this code enough to satisfy our tests? Let's find out:

```
28 examples, 0 failures
```

Yes it is. Before we move onto the next couple of commands, we should ensure that we're satisfying this requirement of our problem description:

> It is assumed that the PLACE command has only one space, that is PLACE 1, 2, NORTH is an invalid command.

Let's write a new test for this in `spec/toy_robot/command_spec.rb`:

```ruby
it "returns :invalid for an invalid PLACE command" do
  command = ToyRobot::Command.process("PLACE 1, 2, NORTH")
  expect(command).to eq([:invalid, "PLACE 1, 2, NORTH"])
end
```

When we run this test, we'll see that our `Command` class doesn't handle invalid commands yet:

```
Failure/Error: expect(command).to eq([:invalid, "PLACE 1, 2, NORTH"])

  expected: [:invalid, "PLACE 1, 2, NORTH"]
       got: [:place, 0, 0, nil]

  (compared using ==)
```

It would be pretty weird if it did handle invalid commands already. Let's change our `process` method to ensure the command is valid before we return it:

```ruby
module ToyRobot
  class Command
    def self.process(command)
      if /\APLACE (\d+),(\d+),(\w+)\Z/.match(command)
        [:place, $1.to_i, $2.to_i, $3]
      else
        [:invalid, command]
      end
    end
  end
end
```

Calling `match` on a regular expression will return a `MatchData` object if the regular expression matches, and `nil` if it doesn't. We can use this to our advantage in the `process` method here so that if a `MatchData` object is returned then we know that the command is valid.  If `nil` is returned, then we know that the command is invalid.

Running the test again will show that it's now passing:

```
29 examples, 0 failures
```

Great! We're now able to process both a valid `PLACE` and an invalid `PLACE` command. Let's look at adding support for the other commands: `MOVE`, `LEFT`, `RIGHT` and `REPORT`.

We'll start with `MOVE`. Let's write a test for this:

```ruby
context "MOVE" do
  it "processes the command" do
    command, *args = ToyRobot::Command.process("MOVE")
    expect(command).to eq(:move)
    expect(args).to be_empty
  end
end
```

The `MOVE` command doesn't have any arguments and we assert as much in our test. When we run this new test, it will fail:

```
Failure/Error: expect(command).to eq(:move)

  expected: :move
       got: :invalid

  (compared using ==)
```

This test is failing because `ToyRobot::Command` doesn't know about the `MOVE` command. We're going to need to update the `process` method so that it supports both the `PLACE` and `MOVE` commands. Let's change this method now:

```ruby
module ToyRobot
  class Command
    def self.process(command)
      case command
      when /\APLACE (\d+),(\d+),(\w+)\Z/
        [:place, $1.to_i, $2.to_i, $3]
      when /\AMOVE\Z/
        [:move]
      else
        [:invalid, command]
      end
    end
  end
end
```

We've turned our `if` statement into a `case` statement as we need to handle more than just a `true`/`false` check. We now have two commands that `process` can handle -- `PLACE` and `MOVE` -- and if `process` doesn't know about a command then it will still return `[:invalid, command]`

Running this test again will show that the `process` method now works with the `MOVE` command:

```
30 examples, 0 failures
```

Great, let's move (ahem) on to the `LEFT`, `RIGHT` and `REPORT` commands now. The tests for these will be identical to the `MOVE` test:

```ruby
context "LEFT" do
  it "processes the command" do
    command, *args = ToyRobot::Command.process("LEFT")
    expect(command).to eq(:left)
    expect(args).to be_empty
  end
end

context "RIGHT" do
  it "processes the command" do
    command, *args = ToyRobot::Command.process("RIGHT")
    expect(command).to eq(:right)
    expect(args).to be_empty
  end
end

context "REPORT" do
  it "processes the command" do
    command, *args = ToyRobot::Command.process("REPORT")
    expect(command).to eq(:report)
    expect(args).to be_empty
  end
end
```

We've written all these tests at the same time because their implementation is identical and it would be laborious to get each one to pass individually before moving onto the next. Each test asserts that when we receive the `LEFT`, `RIGHT` or `REPORT` command that the command is then transformed into a symbol matching that command: `:left`, `:right` and `:report` respectively.

Running the tests for these commands will show that the `ToyRobot::Command` doesn't yet understand what we mean by them:

```
Failure/Error: expect(command).to eq(:left)

  expected: :left
       got: :invalid

  (compared using ==)

  Diff:
  @@ -1,2 +1,2 @@
  -:left
  +:invalid
```

Let's make the `ToyRobot::Command` class capable of handling these new commands by changing its `process` method to this:

```ruby
module ToyRobot
  class Command
    def self.process(command)
      case command
      when /\APLACE (\d+),(\d+),(\w+)\Z/
        [:place, $1.to_i, $2.to_i, $3]
      when /\AMOVE\Z/
        [:move]
      when /\ALEFT\Z/
        [:left]
      when /\ARIGHT\Z/
        [:right]
      when /\AREPORT\Z/
        [:report]
      else
        [:invalid, command]
      end
    end
  end
end
```

The code for the `MOVE`, `LEFT`, `RIGHT` and `REPORT` commands is identical. We match a string that is exactly the command and nothing else, and then convert that into an array which contains a symbol with the same name as the command itself.

Running the tests again will now show that the `ToyRobot::Command` class understands all the commands it needs to:

```
33 examples, 0 failures
```

Nice. We now have some code that can understand those commands coming in from the file and turn them into arrays like `[:place, 0, 0, "NORTH"]` and `[:move]`. The next thing that we'll need to do is to create a way of passing these commands through to the simulator.

## Running commands

We are so very close to having our application work completely. In this section we're going to be pulling together all the pieces that we've built so far and actually running our toy robot simulation.

We're now going to take a look at this particular part of our problem description:

> The application reads a file using a name passed in the command line

The way we're going to do this is to write a small CLI (command line interface) for the code that we currently have. This CLI will read the commands from a specified file, process them through `ToyRobot::Command` and then it will run the robot's simulation with those processed commands.

When we write a CLI into a gem like the one we've been writing, the code for it goes into the `exe` directory. When the gem is installed, any file in the `exe` directory will be made available to the system as an executable. This means if someone was to install our `toy_robot` gem and we had a file at `exe/toy_robot`, they would then be able to run our code through the `toy_robot` command:

```
toy_robot commands.txt
```

Our problem description says that we need a way to read a file using a name passed in the command line and we're going to attend to this part of the problem by putting a file at `exe/toy_robot` to make it very easy to run our application.

Let's go ahead and create that new file now at `exe/toy_robot`:

```ruby
#!/usr/bin/env ruby

require 'toy_robot'

cli = ToyRobot::CLI.new
commands = cli.load_commands(ARGV[0])
cli.run(commands)
```

The `#!/usr/bin/env ruby` line at the top here indicates is a [she-bang](https://en.wikipedia.org/wiki/Shebang_(Unix)), and will mean this program is executed as a Ruby script; exactly as if we ran `ruby exe/toy_robot`.

We'll need to make this file executable, and we can do that with this command:

```
chmod +x exe/toy_robot
```

In this file, we require our application's main file `lib/toy_robot.rb`. We then initialize a new instance of the `ToyRobot::CLI` class, which will be responsible for handling our applications CLI responsibilities. One of these responsibilities will be to load a file, which is referred to here as `ARGV[0]`. `ARGV[0]` just means the first argument passed to the program:

```
exe/toy_robot commands.txt
```

The `ARGV[0]` variable in that command would be `"commands.txt"`, and so `load_commands` gets `"commands.txt"`. The `load_commands` method will then be responsible for processing the commands in this file, parsing them with the `ToyRobot::Command` class that we just worked on. The `run` method will then run those commands.

If there's a `REPORT` command then `ToyRobot::CLI` should then output some text to tell us where our robot is and what direction it is facing:

```
Robot is at (2, 3) and is facing NORTH
```

It's pretty exciting that we're very close to having our application working completely. This CLI part is the one remaining missing piece of our application and it will bring everything together. Let's go about writing some tests for this class.

Let's write our first test for `ToyRobot::CLI` which will test that when `load_commands` is called, it loads commands in from the specified file:

```ruby
require 'spec_helper'

describe ToyRobot::CLI do
  subject { ToyRobot::CLI.new }

  it "loads commands from a file" do
    path = File.dirname(__FILE__) + "/../fixtures/commands.txt"
    commands = subject.load_commands(path)
    expect(commands).to eq([
      [:place, 0, 0, "NORTH"],
      [:move],
      [:right],
      [:left],
      [:report]
    ])
  end
end
```

In this test the path we're specifying to the `commands.txt` will point to a file at `spec/fixtures/commands.txt`, which doesn't yet exist.

<aside>
  <p>
    The directory is called <code>spec/fixtures</code> because the data contained in it is in a fixed state. <a href="https://en.wikipedia.org/wiki/Test_fixture">Read more about test fixtures on Wikipedia.</a>
  </p>
</aside>

When the commands are loaded from that file, we're asserting that they're output in the format that `ToyRobot::Command` outputs.

To make this test work at all, we'll need the `commands.txt` file. Let's create this file now:

```
PLACE 0,0,NORTH
MOVE
RIGHT
LEFT
REPORT
```


This `commands.txt` contains all the commands that our robot should respond to, and will therefore be a thorough enough test here.

When `load_commands` runs in the test, we're then asserting that the commands it has loaded from the `spec/fixtures/commands.txt` file are in a particular format: a two-dimensional array. Each element in the array represents each command, and when we write the `run` method it will know what to do with these commands.

To make this test work, we're going to need to create a class called `ToyRobot::CLI`. Let's do that now in `lib/toy_robot/cli.rb`:

```ruby
module ToyRobot
  class CLI

  end
end
```

We'll then need to require this file in `lib/toy_robot.rb` so that our test can see the constant:

```ruby
require "toy_robot/cli"
```

Okay, with that done let's run our test and see what happens:

```
Failure/Error: commands = subject.load_commands(path)

NoMethodError:
  undefined method `load_commands' for #<ToyRobot::CLI:..>
```

We're going to need to add the `load_commands` method to `ToyRobot::CLI`. This method will need to read in the file specified and return a list of commands:

```ruby
module ToyRobot
  class CLI
    def load_commands(commands_file)
      File.readlines(commands_file).map do |command|
        ToyRobot::Command.process(command)
      end
    end
  end
end
```

The `File.readlines` method here will take each line of the file and put it as an element in an array. If we go into `irb` and use `File.readlines`, we can see what this method does for ourselves:

```
irb(main):001:0> File.readlines("spec/fixtures/commands.txt")
=> ["PLACE 0,0,NORTH\n", "MOVE\n", "RIGHT\n", "LEFT\n", "REPORT\n"]
```

Each of these commands is then processed by `ToyRobot::Command.process`, which then should turn each command into its Array variant. If that happens, then our test should be happy. Let's run the tests and see:

```
34 examples, 0 failures
```

Great! Our `ToyRobot::CLI#load_commands` method now works. We've got most of our `exe/toy_robot`'s functionality implemented:

```ruby
#!/usr/bin/env ruby

require 'toy_robot'

cli = ToyRobot::CLI.new
commands = cli.load_commands(ARGV[0])
cli.run(commands)
```

The next thing we need to do is to add the `run` method to `ToyRobot::CLI` so that commands actually get ran. When a command is ran through this method, `ToyRobot::CLI`, the command should be passed to a `ToyRobot::Simulator` instance, as this instance will know about a `ToyRobot::Robot` instance, and that `ToyRobot::Robot` class contains the "brains" of the robot.

Let's write a test for this `run` method:

```ruby
context "run" do
  let(:simulator) { instance_double(ToyRobot::Simulator) }

  before do
    allow(subject).to receive(:simulator) { simulator }
  end

  context "place command" do
    it "passes a place command to the simulator" do
      expect(simulator).to receive(:place).with(0, 0, "NORTH")
      subject.run([[:place, 0, 0, "NORTH"]])
    end
  end
end
```

With this test, we've got a bit of setup before the test happens. To start with, we create an instance double of the `ToyRobot::Simulator` class because instantiating `ToyRobot::Simulator` requires us to pass another argument (`table`). The `CLI` class doesn't care about a table, and so it's easier here to use an `instance_double` for that reason.

Further more, `instance_double` allows us to verify expectations that we set on the instance. When we expect `simulator` to receive `:place`, RSpec will validate that instances of the specified class definitely do respond to a `place` method and that it supports 3 arguments. This is important because if we didn't have that verification in place, we may end up calling methods of `Simulator` which have a different number of arguments, and that would make our tests pass but in "live" tests of `ToyRobot::CLI` it would break.

It's important to note that in this test that we're on-purpose _not_ testing the behaviour of `ToyRobot::Simulator`. Testing the behaviour of that class is best left to the tests for that class. The only thing that we're testing in `ToyRobot::CLI`'s tests is that when `ToyRobot::CLI#run` is called with a list of commands that includes `:place`, that the `ToyRobot::Simulator` instance receives the `place` command, with the correct arguments.

Running this test will show us that the `run` method isn't defined on `ToyRobot::CLI`:

```
Failure/Error: subject.run([[:place, 0, 0, "NORTH"]])

NoMethodError:
  undefined method `run' for #<ToyRobot::CLI:...>
```

Let's define this method in `ToyRobot::CLI`:

```ruby
module ToyRobot
  class CLI
    def load_commands(commands_file)
      File.readlines(commands_file).map do |command|
        ToyRobot::Command.process(command)
      end
    end

    def run(commands)
    end
  end
end
```

Running the test again will show us that the `simulator` isn't receiving the `place` method as we expect:

```
Failure/Error: expect(simulator).to receive(:place).with(0, 0, "NORTH")

  (InstanceDouble(ToyRobot::Simulator) (anonymous)).place(0, 0, "NORTH")
      expected: 1 time with arguments: (0, 0, "NORTH")
      received: 0 times
```

The purpose of the `run` method is to take the commands it receives and then pass these onto `ToyRobot::Simulator`. Let's update the `run` method now to do that:

```
def run(commands)
  commands.each do |command, *args|
    simulator.send(command, *args)
  end
end
```

This new `run` method takes each of the commands and will call `send` with the name of the command, passing in the necessary arguments too. In the case of our `[:place, 0, 0, "NORTH"]` command, the `@simulator` here will receive a call to the `place` method, and the arguments passed along will be `(0, 0, "NORTH")`.

That sounds remarkably like what our test is expecting. Let's make sure that our test is now happy:

```
35 examples, 0 failures
```

Yes, it is! We've now ensured that our `ToyRobot::CLI#run` method can correctly handle the `[:place, 0, 0, "NORTH"]` command. However, we should really make sure that it works with the other commands too.

Let's add a new test to `ToyRobot::CLI` for the `[:move]` command:

```ruby
context "move command" do
  it "passes the command to the simulator" do
    expect(simulator).to receive(:move)
    subject.run([[:move]])
  end
end
```

This test is very similar to the one for the `[:place, ...]` command, except we're expecting that the simulator to receive the `move` method. Running this test will show us that `ToyRobot::Simulator` does not implement this method:

```
Failure/Error: expect(simulator).to receive(:move)
  the ToyRobot::Simulator class does not implement the instance method: move
```

This is a great demonstration of what `instance_double` provides us with: it's the piece here which is telling us that the `ToyRobot::Simulator` class doesn't implement the `move` method. It's a great prompt of what to do next: implement the `ToyRobot::Simulator#move` method. Let's add a test for this new method to `spec/toy_robot/simulator_spec.rb`:

```
context "when robot has been placed" do
  let(:robot) { instance_double(ToyRobot::Robot) }
  before { allow(subject).to receive(:robot).and_return(robot) }

  it "tells the robot to move" do
    expect(robot).to receive(:move)
    subject.move
  end
end
```

With this new test, we're telling the simulator should act as if the robot has been placed before we assert that `move` happens. Later on we'll add a test for what happens when `move` is called and the robot _hasn't_ been placed, but for now we'll be focussing on this case.

We're using `instance_double` again because we want to make sure that the instance of `ToyRobot::Robot` that the simulator knows about responds to `move`. In the test itself, we're asserting that when the simulator has `move` called on it, that the robot is then told to move.

The `ToyRobot::Simulator` class, as we saw earlier, doesn't implement the `move` method and so our test will fail:

```
Failure/Error: subject.move

NoMethodError:
  undefined method `move' for #<ToyRobot::Simulator:0x007fd27e85c6d8>
```

We knew as much already, and now we have another simple test to prove it. Let's add this `move` method to the code inside `lib/toy_robot/simulator.rb`:

```ruby
def move
  robot.move
end
```

This is one of the simpler methods that we've written in recent times and it should satisfy the requirements of our test. Let's run just this one test with `rspec spec/toy_robot/simulator_spec.rb:21`

```
1 example, 0 failure
```

Great! Now that `ToyRobot::Simulator` implements the `move` method, that should satisfy our test for the `ToyRobot::CLI` class. Let's run all the tests now and find out if that is the case:

```
37 examples, 0 failures
```

Yes, it is! We've got a test that ensures that when `ToyRobot::CLI` encounters a `[:move]` command it passes that command onto the `ToyRobot::Simulator` instance. We have another test to make sure that the command makes it the rest of the way to the `ToyRobot::Robot` instance that the simulator knows about.

We've now got `[:left]`, `[:right]` and `[:report]` command handling to implement for `ToyRobot::CLI`. The process of implementing these will be the same as the `[:move]` command, so let's add all the tests we need for these to the tests for `ToyRobot::CLI`:

```ruby
context "left command" do
  it "passes the command to the simulator" do
    expect(simulator).to receive(:left)
    subject.run([[:left]])
  end
end

context "right command" do
  it "passes the command to the simulator" do
    expect(simulator).to receive(:right)
    subject.run([[:right]])
  end
end

context "report command" do
  it "passes the command to the simulator" do
    expect(simulator).to receive(:report)
    subject.run([[:report]])
  end
end
```

When we run these tests we'll see the same thing that happened with the `move` method: it isn't implemented on `ToyRobot::Simulator`:

```
Failure/Error: expect(simulator).to receive(:left)
  the ToyRobot::Simulator class does not implement the instance method: left
```

As we did for the `move` method, we'll need to write some tests for the `left`, `right` and `report` methods for `ToyRobot::Simulator`, just to make sure it is behaving. Let's add these now to `spec/toy_robot/simulator_spec.rb`:

```ruby
context "when robot has been placed" do
  let(:robot) { instance_double(ToyRobot::Robot) }
  before { allow(subject).to receive(:robot).and_return(robot) }

  it "tells the robot to move" do
    expect(robot).to receive(:move)
    subject.move
  end

  it "tells the robot to turn left" do
    expect(robot).to receive(:left)
    subject.left
  end

  it "tells the robot to turn right" do
    expect(robot).to receive(:right)
    subject.right
  end

  it "tells the robot to report" do
    expect(robot).to receive(:report)
    subject.report
  end
end
```

These tests will fail for the same reason as the `ToyRobot::CLI` tests: because the `left`, `right` and `report` methods are not defined on `ToyRobot::Simulator`. Let's do that now:

```ruby
def left
  robot.left
end

def right
  robot.right
end

def report
  robot.report
end
```

We've written these methods in the simplest way to make the tests pass again. If we run them all once more, we'll see that all of them pass:

```
43 examples, 0 failures
```

Great! We've proven _theoretically_ that our `ToyRobot::CLI` class will actually run a simulation of our robot by having several tests for its functionality. But wouldn't it be cool to actually see it run?

## Running the robot

Let's create a new file called `commands.txt` and put this into it:

```
PLACE 0,0,NORTH
MOVE
RIGHT
MOVE
LEFT
MOVE
MOVE
LEFT
MOVE
REPORT
```

These instructions should make our robot move like this:

<center>
  <img src='/images/toy_robot/robot-movements.png'>
</center>

Once the robot gets there, it should tell us what position it's at and where it's facing because we've issued it with a `REPORT` command. From the diagram, we can see that the data reported should be:

```ruby
{north: 3, east: 3, direction: "EAST"}
```

We'll make this data a little bit better looking when we get around to it. We'll output something like this:

```
Robot is currently at (3, 3) and it's facing EAST
```

Alright, let's try running our application now. We can do that by running this command:

```
bundle exec exe/toy_robot commands.txt
```

Unfortunately, Bundler's default gemspec gets in the way of us looking at this:

```
bundler: failed to load command: exe/toy_robot (exe/toy_robot)
Gem::InvalidSpecificationException:
  The gemspec at ...toy_robot/toy_robot.gemspec is not valid.
  Please fix this gemspec.
  The validation error was '"FIXME" or "TODO" is not a description'
```

Because we've used `bundle gem` as a foundation, Bundler is treating this project as if it were a gem we were going to release. Bundler tries to enforce good descriptions on gems, and this is what's happening here.

To fix this, we can open `toy_robot.gemspec` and change these two lines:

```ruby
spec.summary       = %q{Write a short summary, because Rubygems requires one.}
spec.description   = %q{TODO: Write a longer description or delete this line.}
```

To this:

```ruby
spec.summary       = %q{A Toy Robot Simulator}
spec.description   = %q{A Toy Robot Simulator}
```

Let's try it one more time:

```
bundle exec exe/toy_robot commands.txt
bundler: failed to load command: exe/toy_robot (exe/toy_robot)
NameError: undefined local variable or method `simulator' for #<ToyRobot::CLI:0x007fd9e19b3120>
  /Users/ryanbigg/code/toy_robot/lib/toy_robot/cli.rb:11:in `block in run'
  /Users/ryanbigg/code/toy_robot/lib/toy_robot/cli.rb:10:in `each'
  /Users/ryanbigg/code/toy_robot/lib/toy_robot/cli.rb:10:in `run'
  exe/toy_robot:7:in `<top (required)>'
```

Our attempt is failing yet again. This seems to be happening because the `ToyRobot::CLI` class doesn't have a `simulator` method. Our tests are all passing because we're stubbing this method when we need to use it:

```ruby
context "run" do
  let(:simulator) { instance_double(ToyRobot::Simulator) }

  before do
    allow(subject).to receive(:simulator) { simulator }
  end

  ...
```

We'll need to define this `simulator` method if we want our program to execute! To do this, we need to make `ToyRobot::CLI` aware of a `ToyRobot::Simulator` instance, and we can do that by initializing one in the `initialize` method of `ToyRobot::CLI`. The `ToyRobot::Simulator` needs to know about the table it is running a simulation on, and so we should initialize a `ToyRobot::Table` instance too:

```ruby
def initialize
  table = ToyRobot::Table.new(5, 5)
  @simulator = ToyRobot::Simulator.new(table)
end
```

Next we need to define a `simulator` method on `ToyRobot::CLI` instances, which we can do by adding an `attr_reader` for `simulator` at the top of the class:

```
module ToyRobot
  class CLI
    attr_reader :simulator
```

This reader will use the `@simulator` variable that we've set in `initialize` as the value to return whenever the `simulator` method is called.

Let's try running our application once more:

```
bundle exec exe/toy_robot commands.txt
```

Hmmm nothing was output. We've asked the robot to report, but we're not seeing anything on the screen. We would expect to, as the problem description says this:

> * REPORT announces the X,Y and F of the robot.

This announcement isn't happening because because the `ToyRobot::Simulator#report` method doesn't do anything with the data it gets back from `ToyRobot::Robot#report`:

```ruby
def report
  robot.report
end
```

In the interests in getting something working quickly, let's just change this code to output something. We'll then write a test to validate that `Simulator#report` does output something a little later.

```ruby
def report
  position = robot.report
  puts "Robot is currently at (#{position[:north]}, #{position[:east]})" +
    " and it's facing #{position[:direction]}"
end
```

Okay, fourth time's a charm! Let's try running our simulator again:

```
bundle exec exe/toy_robot commands.txt
Robot is currently at (3, 3) and it's facing EAST
```

Hooray! Our robot simulation is now working! The commands are read in from the `commands.txt` file, processed by `ToyRobot::Command` and then `ToyRobot::CLI` handles running these commands by passing them to the simulator. Everything is all working together in harmony.

Let's run our tests to make sure that everything's still working after the changes we've made to get our application to work:

```
Failure/Error:
  puts "Robot is currently at (#{position[:north]}, #{position[:east]})" +
    " and it's facing #{position[:direction]}"

  NoMethodError:
    undefined method `[]' for nil:NilClass
# ./lib/toy_robot/simulator.rb:29:in `report'
# ./spec/toy_robot/simulator_spec.rb:38:in `block (3 levels) in <top (required)>'
```

Oh no, we've broken a test! Let's take a look at that particular test:

```
it "tells the robot to report" do
  expect(robot).to receive(:report)
  subject.report
end
```

The test asserts that when `subject.report` is called, `robot` receives `report`. The test seems to be doing that fine, because the `report` method in `lib/toy_robot/simulator.rb` gets to its second line:

```
def report
  position = robot.report
  puts "Robot is currently at (#{position[:east]}, #{position[:north]})" +
    " and it's facing #{position[:direction]}"
end
```

The error looks to be coming from the calls to `position` here, and it looks like from the error that `position` is `nil`. This is happening because in our test when we do this:

```ruby
expect(robot).to receive(:report)
```

We're stubbing the method to return `nil`. To make our test work, we're going to need to get the `report` method to return a `Hash` that matches what `ToyRobot::Robot#report` normally would return. Let's change that expectation in our test to this:

```ruby
expect(robot).to receive(:report) { { north: 3, east: 3, direction: "NORTH" }}
```

Now when `robot.report` is called, it will return a `Hash` that will satisfy the `Simulator#report` method's requirements. This should make our test happy. Let's find out with another run:

```
43 examples, 0 failures
```

You may notice that when the test is run, we see the output for `report` in amongst the tests:

```
ToyRobot::Simulator
  places the robot onto a valid position
  cannot place the robot onto an invalid position
  when robot has been placed
    tells the robot to move
    tells the robot to turn left
    tells the robot to turn right
Robot is currently at (3, 3) and it's facing NORTH
    tells the robot to report
```

We really should have a test that asserts that the text there is output when the `report` method is called. We can modify the test that we were just looking at to do this:

```ruby
it "tells the robot to report" do
  expect(robot).to receive(:report) { { north: 3, east: 3, direction: "NORTH" }}
  message = "Robot is currently at (3, 3) and it's facing NORTH\n"
  expect { subject.report }.to output(message).to_stdout
end
```

We've now changed the final line of this test to assert that when `Simulator#report` is called, that there is something output to `stdout`. Running the test again will show that it's still passing:

```
43 examples, 0 failures
```

And if we look at the test output, we'll notice that `Robot is currently at (3, 3) and it's facing NORTH` is no longer output. This is because RSpec is capturing that output so that we can assert on it.

## Verifying the toy robot's behaviour

We've now completed an implementation of our toy robot, or at least we think so. It would be smart of us to go through the problem description one more time and verify that the robot does everything that the description says it should do.

Let's start at the top:

> The application is a simulation of a toy robot moving on a square tabletop, of dimensions 5 units x 5 units. There are no other obstructions on the table surface. The robot is free to roam around the surface of the table. **Any movement that would result in the robot falling from the table is prevented, however further valid movement commands are still allowed.**

We've got a `ToyRobot::Table` class which represents our table, and it is initialized in `ToyRobot::CLI`'s `initialize` method as having the dimensions "5 units by 5 units":

```ruby
def initialize
  table = ToyRobot::Table.new(5, 5)
  @simulator = ToyRobot::Simulator.new(table)
end
```

So far so good. We haven't programmed any obstructions on the table surface, and so the robot is free to roam around as it pleases.

### The robot escapes!

Now about that final sentence. Are we absolutely certain that the robot doesn't continue moving past the boundaries of the table?

<center>
  <img src='/images/toy_robot/robot-falls-off.png'>
</center>

If the robot is asked to move several times from `(0, 0)`, it shouldn't continue past the boundary of the table, which is at `(0, 4)`. We can verify if the robot doesn't do this by creating a `commands.txt` file with this content:

```
PLACE 0,0,NORTH
MOVE
MOVE
MOVE
MOVE
MOVE
MOVE
REPORT
```

With this new variant of `commands.txt`, the robot is asked to move enough times that it should continue past the boundaries of the table. If the robot doesn't move past the boundary, the `REPORT` command should make the robot tell us that it's at `(0, 4)`. Any other position is wrong and we should fix our mistake.

Let's run our robot simulation again to find out if the robot continues past the boundaries:

```
bundle exec exe/toy_robot COMMANDS
Robot is currently at (6, 0) and it's facing NORTH
```

It very much looks like the robot continues past the top boundary at `(0, 4)` and moves through to `(6, 0)`. This behaviour is incorrect, but all our tests are OK as we just saw. We've found a bug that our tests don't cover, and so it's now time to write a _regression test_ for this bug to ensure it doesn't happen again.

We'll write this test at the bottom of `spec/toy_robot/simulator_spec.rb`:

```ruby
context "robot placed at table boundary" do
  before do
    subject.place(0, 4, "NORTH")
  end

  it "cannot move past the table boundary" do
    subject.move
    message = "Robot is currently at (0, 4) and it's facing NORTH\n"
    expect { subject.report }.to output(message).to_stdout
  end
end
```

With this test, we're using the `place`, `move` and `report` methods from `ToyRobot::Simulator` to reproduce the same behaviour as what we just saw. When the robot is placed at `(0, 4)` and asked to `move` and then `report`, the robot should tell us that it's still at `(0, 4)`. This test validates this part of our problem description's requirements is met:

> Any movement that would result in the robot falling from the table is prevented

Running this test will show us that the robot is indeed moving too much:

```
Failure/Error: expect { subject.report }.to output(message).to_stdout

  expected block to output "Robot is currently at (0, 4) and it's facing NORTH\n" to stdout, but output "Robot is currently at (0, 5) and it's facing NORTH\n"
  Diff:
  @@ -1,2 +1,2 @@
  -Robot is currently at (0, 4) and it's facing NORTH
  +Robot is currently at (0, 5) and it's facing NORTH
```

Our robot is indeed moving further than it should be allowed to. Thanks to our very rigourous tests and clean code we've been able to very easily write a brand new test which reproduces this issue.

To fix this test, we're going to need to change the behaviour of the `move` method in `ToyRobot::Simulator`. This method should check with the `ToyRobot::Table` instance that the simulator knows about to see if the next movement of the robot would be a valid placement. However to do that, we're going to need some way of knowing where the robot would move to if it were to move. We would use such a thing in `ToyRobot::Simulator#move` like this:

```ruby
def move
  robot.move if @table.valid_location?(*robot.next_move)
end
```

Where `next_move` would return something like `[5, 0]` indicating the `EAST` and `NORTH` coordinates of where our robot was to move to, if it were to move.

We're going to need to add this `next_move` method to `ToyRobot::Robot` if we wish to use it. Before we add it though, we're going to need to add some tests. Let's write one in `spec/toy_robot/robot_spec.rb` now, underneath the existing "when facing north" `context` block:

```ruby
context "when facing north" do
  subject { ToyRobot::Robot.new(0, 0, "NORTH") }

  ...

  it "next move is to (0, 1)" do
    expect(subject.next_move).to eq([0, 1])
  end
end
```

This test is fairly simple. It says that when the robot is at `(0, 0)` and facing `NORTH`, the next move the robot will undertake will move it to `(0, 1)`. Running just this test will show that the `next_move` method is missing:

```
Failure/Error: expect(subject.next_move).to eq([0, 1])

NoMethodError:
  undefined method `next_move' for #<ToyRobot::Robot:...>
```

So far, our tests only require this method to return `[0, 1]`, and so let's do that now by defining this `next_move` method inside of `ToyRobot::Robot`:

```ruby
def next_move
  [0, 1]
end
```

Running this test once more will show that it is now passing:

```
1 example, 0 failures
```

Ok, we've now got that working but it really does show that the one test we've added isn't thorough enough to make sure `next_move` is going to return anything but `[0, 1]`. Let's add another test to the "when facing south" `context` block in `spec/toy_robot/robot_spec.rb`:

```ruby
context "when facing south" do
  subject { ToyRobot::Robot.new(0, 0, "SOUTH") }

  ...

  it "next move is to (0, -1)" do
    expect(subject.next_move).to eq([0, -1])
  end
end
```

Running just this one test will show that `next_move` is broken:

```
Failure/Error: expect(subject.next_move).to eq([0, -1])

  expected: [0, -1]
       got: [0, 1]

  (compared using ==)
```

The `next_move` method will now need to be written in a way to support both tests. If the robot is facing `NORTH` and is asked `next_move`, then it should return `[0, 1]`, and if it's facing `SOUTH` and asked the same thing, then it should return `[0, -1]`. In another way, when it's facing `NORTH` we should add 1 to its current `NORTH` position, and if it's facing `SOUTH` then we should take 1 from that position.

Let's update the `next_move` method to behave in that way:

```ruby
def next_move
  case @direction
  when "NORTH"
    [@east, @north + 1]
  when "SOUTH"
    [@east, @north - 1]
  end
end
```

Let's run all the tests for `ToyRobot::Robot` with `rspec spec/toy_robot/robot_spec.rb`, just to make sure we haven't broken anything in this class:

```
23 examples, 0 failures
```

All the tests are passing! Great. We should add two more tests for the other two compass directions, `EAST` and `WEST`:

```
context "when facing east" do
  subject { ToyRobot::Robot.new(0, 0, "EAST") }

  ...

  it "next move is to (1, 0)" do
    expect(subject.next_move).to eq([1, 0])
  end
end

context "when facing west" do
  subject { ToyRobot::Robot.new(0, 0, "WEST") }

  ...

  it "next move is to (-1, 0)" do
    expect(subject.next_move).to eq([-1, 0])
  end
end
```

Running just the `ToyRobot::Robot` tests again will show us that these two tests don't work yet:

```
Failure/Error: expect(subject.next_move).to eq([1, 0])

  expected: [1, 0]
       got: nil

  (compared using ==)
```

They don't work because we don't take into account the `EAST` and `WEST` directions in the `next_move` method. Let's update `next_move` to do that now:

```ruby
def next_move
  case @direction
  when "NORTH"
    [@east, @north + 1]
  when "SOUTH"
    [@east, @north - 1]
  when "EAST"
    [@east + 1, @north]
  when "WEST"
    [@east - 1, @north]
  end
end
```

Running the tests again for `ToyRobot::Robot` will show that everything is right with the world:

```
25 examples, 0 failures
```

Or at least, everything is right with `ToyRobot::Robot`. Let's change our `ToyRobot::Simulator#move` method now to use this new method in conjunction with `ToyRobot::Table#valid_location?`:

```ruby
def move
  robot.move if @table.valid_location?(*robot.next_move)
end
```

There we go. Now the `move` method should only move the robot if the next movement the robot would do is a valid location according to `ToyRobot::Table#valid_location?`. Let's run just the final test in `ToyRobot::Simulator`'s tests now to see if we've fixed the issue of the robot moving off the end of the table:

```
1 example, 0 failures
```

Yes we have! Our robot will now no longer move off the edge of the table. We can verify this ourselves again by running the application itself:

```
bundle exec exe/toy_robot commands.txt
Robot is currently at (0, 4) and it's facing NORTH
```

The robot is now correctly reporting it is at `(0, 4)` instead of `(0, 5)`.

Here's a good point to make sure all the tests are still working. Let's run them all and see:

```
Failure/Error: robot.move if @table.valid_location?(*robot.next_move)
  #<InstanceDouble(ToyRobot::Robot) (anonymous)> received unexpected message :next_move with (no args)
# ./lib/toy_robot/simulator.rb:16:in `move'
# ./spec/toy_robot/simulator_spec.rb:23:in `block (3 levels) in <top (required)>'
```

Oops, we've appear to have broken one of our tests. The test that we've broken in is this one:

```ruby
context "when robot has been placed" do
  let(:robot) { instance_double(ToyRobot::Robot) }
  before { allow(subject).to receive(:robot).and_return(robot) }

  it "tells the robot to move" do
    expect(robot).to receive(:move)
    subject.move
  end

  ...
```

The `move` method now does a bit more than call `move` on the robot. It also asks the robot what its next move is going to be. We're using an `instance_double` in this test and we haven't configured it to respond to the `next_move` method, which is why we're seeing what we're seeing here. To fix this test, we just need to tell the `instance_double` how to respond to the `next_move` method:

```ruby
let(:robot) { instance_double(ToyRobot::Robot, next_move: [0, 0]) }
```

We're returning `[0, 0]` here as it is a valid location to move to, and so the simulator should end up calling the `move` method on `robot`, as our test requires.

Let's run all the tests again and see if it is all working:

```
48 examples, 0 failures
```

Yes! We now have a fully functional robot simulation once more.

### Continuing verification

Let's continue on with verifying that our robot meets the problem description's criteria. The next part says:

> The application reads a file using a name passed in the command line, the following commands are valid:

> ```
> PLACE X,Y,F
> MOVE
> LEFT
> RIGHT
> REPORT
> ```

We've verified this a few times already by running our `exe/toy_robot` command:

```
bundle exec exe/toy_robot commands.txt
```

So check on that one!

The next few lines go through the commands of our robot and what it should do when it is issued with them:

```
> * PLACE will put the toy robot on the table in position X,Y and facing NORTH, SOUTH, EAST or WEST.
> * The origin (0,0) is the SOUTH WEST most corner.
> * All commands are ignored until a valid PLACE is made.
> * MOVE will move the toy robot one unit forward in the direction it is currently facing.
> * LEFT and RIGHT rotates the robot 90 degrees in the specified direction without changing the position of the robot.
> * REPORT announces the X,Y and F of the robot.
```

We handle all of these points through the classes in our application. `PLACE` is handled by `ToyRobot::Simulator`. We assume that the origin is `(0, 0)` in `ToyRobot::Table`. But do we ignore commands until a valid `PLACE` is made?

An easy way to test this would be to remove the `PLACE` command from the top of `commands.txt` and try to run our robot again. Let's make that change to `commands.txt` now:

```
MOVE
MOVE
MOVE
MOVE
MOVE
MOVE
REPORT
```

And we'll run our robot:

```
bundle exec exe/toy_robot commands.txt
```

When we do so, we'll see this:

```
bundler: failed to load command: exe/toy_robot (exe/toy_robot)
NoMethodError: undefined method `next_move' for nil:NilClass
  /Users/ryanbigg/code/toy_robot/lib/toy_robot/simulator.rb:16:in `move'
```

Our toy robot is yet again broken! Isn't it a great thing that we're testing it out?

This time our robot is broken inside the `ToyRobot::Simulator#move` method:

```
def move
  robot.move if @table.valid_location?(*robot.next_move)
end
```

The exception says that we're calling `next_move` on `nil`, and the only place inside this method where we're doing that is when we call `robot.next_move`. This would indicate that the `robot` method is returning `nil`. This is happening because the value that `robot` would normally return is the `@robot` variable, which is only set inside the `place` method. The `place` method isn't being called here, and so we're seeing this error when `move` is called.

We're going to need to add a check in to `move` to ensure that `move` isn't called unless the robot has been placed. We'll call this check `robot_placed?` and it will return `true` if the robot has been placed, and `false` if it hasn't.

Let's add a couple of tests for this method before we write it. These tests will go into `spec/toy_robot/simulator_spec.rb`. Here's the first test. We'll place it just after the first two tests in this file:

```ruby
it "places the robot onto a valid position" do
  subject.place(0, 0, "NORTH")
  expect(subject.robot).not_to be_nil
end

it "cannot place the robot onto an invalid position" do
  subject.place(5, 5, "NORTH")
  expect(subject.robot).to be_nil
end

it "does not have the robot placed by default" do
  expect(subject.robot_placed?).to eq(false)
end
```

When the simulator hasn't received `place` call, our robot should not have been placed yet. Let's add the other test to the "when robot has been placed" `context` block:

```ruby
context "when robot has been placed" do
  ...

  it "has a placed robot" do
    expect(subject.robot_placed?).to eq(true)
  end
end
```

Running these tests now will show that the `robot_placed?` method doesn't exist:

```
Failure/Error: expect(subject.robot_placed?).to eq(false)

NoMethodError:
  undefined method `robot_placed?' for #<ToyRobot::Simulator:...>
```

Let's define this method now in `ToyRobot::Simulator`:

```ruby
def robot_placed?
  !robot.nil?
end
```

To determine if our robot has been placed yet, we need to check for the presence of `robot`. While the code inside the method is shorted than the method name itself, the code does not fully communicate the intent of what it does. This is why we're wrapping it in a method called `robot_placed?`. This method name better communicates the intent of our check.

Next, we'll need a test which reproduces the bad behaviour of our application, one that tries to move the robot without it having being placed first. If we look back at the way that our attempt failed earlier:

```
bundler: failed to load command: exe/toy_robot (exe/toy_robot)
NoMethodError: undefined method `next_move' for nil:NilClass
  /Users/ryanbigg/code/toy_robot/lib/toy_robot/simulator.rb:16:in `move'
```

We'll see that the breakage occurs when `ToyRobot::Simulator#move` is called. Therefore it makes sense to test this method's behaviour, but only in a case where the robot hasn't yet been placed. To test this, we'll add another test to `ToyRobot::Simulator`'s tests, underneath the first test that we just added:

```ruby
it "does not have the robot placed by default" do
  expect(subject.robot_placed?).to eq(false)
end

it "does not move the robot" do
  expect { subject.move }.to_not raise_error
end
```

We're asserting with this new test that calling `move` does not raise an error. If we run this test, we'll see that it breaks:

```
Failure/Error: expect { subject.move }.to_not raise_error

  expected no Exception, got #<NoMethodError: undefined method `next_move' for nil:NilClass> with backtrace:
    # ./lib/toy_robot/simulator.rb:17:in `move'
```

This is now breaking in the same way as when we ran `bundle exec exe/toy_robot commands.txt`. Wonderful! Let's now go about fixing this. We can fix it by making the `move` method not do anything if the robot hasn't yet been placed:

```
def move
  return unless robot_placed?
  robot.move if @table.valid_location?(*robot.next_move)
end
```

The first line in this method will return unless the robot has been placed. If the robot has been placed, then this method will continue on as per normal.

Running the tests again will show that everything is now working:

```
51 examples, 0 failures
```

We should also take care that the other methods such as `left`, `right`, and `report` also do not break if the robot hasn't been placed yet. Let's add some tests for these too:

```ruby
it "turning an unplaced robot left does not cause an exception" do
  expect { subject.left }.to_not raise_error
end

it "turning an unplaced robot right does not cause an exception" do
  expect { subject.right }.to_not raise_error
end

it "asking an unplaced robot to report does not cause an exception" do
  expect { subject.right }.to_not raise_error
end
```

If we run these tests now, we'll see that all of them fail in the same way as our `move` method:

```
Failure/Error: expect { subject.left }.to_not raise_error

  expected no Exception, got #<NoMethodError: undefined method `left' for nil:NilClass> with backtrace:
    # ./lib/toy_robot/simulator.rb:21:in `left'
    # ./spec/toy_robot/simulator_spec.rb:26:in `block (3 levels) in <top (required)>'
    # ./spec/toy_robot/simulator_spec.rb:26:in `block (2 levels) in <top (required)>'
```

We can fix all these tests the same way that we fixed the `move` test: by using the `robot_placed?` method in the `left`, `right` and `report` methods:

```ruby
def left
  return unless robot_placed?
  robot.left
end

def right
  return unless robot_placed?
  robot.right
end

def report
  return unless robot_placed?
  position = robot.report
  puts "Robot is currently at (#{position[:east]}, #{position[:north]})" +
    " and it's facing #{position[:direction]}"
end
```

Another run of the tests will now show that they're all working:

```
54 examples, 0 failures
```

Similarly, if we run our application again, it will not crash:

```
bundle exec exe/toy_robot commands.txt
```

Nothing is output because our robot hasn't been placed yet and so we're ignoring all commands in that file. Let's verify that not _all_ the commands are ignored in the file, just the ones up until the time the robot is placed. We'll change our `commands.txt` to this:

```
MOVE
MOVE
MOVE
MOVE
PLACE 0,0,NORTH
MOVE
MOVE
REPORT
```

Our robot should move two spaces forward, and so it should end up at `(0, 2)` and it should be facing `NORTH`. Running our application again will show that this is indeed the case:

```
bundle exec exe/toy_robot commands.txt
Robot is currently at (0, 2) and it's facing NORTH
```

Wonderful! Let's keep going through the problem description now.

> * MOVE will move the toy robot one unit forward in the direction it is currently facing.

Yes, we've verified that our robot does this.

> * LEFT and RIGHT rotates the robot 90 degrees in the specified direction without changing the position of the robot.

We've also verified that the robot does this.

> * REPORT announces the X,Y and F of the robot.

And this.

> The file is assumed to have ASCII encoding.

We don't make any assumptions one way or the other, and so this is fine.

> It is assumed that the PLACE command has only one space, that is PLACE 1, 2, NORTH is an invalid command.

Hmmm, I don't think we've checked this one. Let's change our `commands.txt` to this to verify if our application ignores the example invalid `PLACE` command:

```
PLACE 1, 2, NORTH
MOVE
REPORT
```

When we run our application, we would expect nothing to happen because that first `PLACE` command is invalid. Let's run it and find out:

```
bundle exec exe/toy_robot commands.txt
bundler: failed to load command: exe/toy_robot (exe/toy_robot)
NoMethodError: undefined method `invalid' for #<ToyRobot::Simulator:0x007fb2621d7c90>
  /Users/ryanbigg/code/toy_robot/lib/toy_robot/cli.rb:18:in `block in run'
  /Users/ryanbigg/code/toy_robot/lib/toy_robot/cli.rb:17:in `each'
  /Users/ryanbigg/code/toy_robot/lib/toy_robot/cli.rb:17:in `run'
  exe/toy_robot:7:in `<top (required)>'
```

Oops! It looks like we have another thing broken in our application. This time it's because the `invalid` method is missing on `ToyRobot::Simulator`. If we look back in the stacktrace, we can see that this exception is happening because of the `run` method on `ToyRobot::CLI`:

```ruby
def run(commands)
  commands.each do |command, *args|
    simulator.send(command, *args)
  end
end
```

This method takes all the commands loaded from `load_commands` and tries to call `send` on `simulator`. But how are we getting `invalid`? That is coming from `ToyRobot::Command.process`:

```ruby
module ToyRobot
  class Command
    def self.process(command)
      case command
      when /\APLACE (\d+),(\d+),(\w+)\Z/
        [:place, $1.to_i, $2.to_i, $3]
      when /\AMOVE\Z/
        [:move]
      when /\ALEFT\Z/
        [:left]
      when /\ARIGHT\Z/
        [:right]
      when /\AREPORT\Z/
        [:report]
      else
        [:invalid, command]
      end
    end
  end
end
```

When this class doesn't recognise a command, it will return `[:invalid, command]`. Then when `ToyRobot::CLI` receives that array, it will try to call `invalid` on `ToyRobot::Simulator` with that command. Because `invalid` is missing, we're seeing this exception.

We should add an `invalid` method to `ToyRobot::Simulator` here which will output a message telling us that the command is invalid. But first, let's write a test in `spec/toy_robot/simulator_spec.rb`:

```ruby
it "informs us when a command is invalid" do
  message = "'PLACE 1, 2, NORTH' is an invalid command\n"
  expect { subject.invalid("PLACE 1, 2, NORTH") }.to output(message).to_stdout
end
```

Running this test will fail because the `invalid` method isn't there:

```
Failure/Error: expect { subject.invalid("PLACE 1, 2, NORTH") }.to output(message).to_stdout

NoMethodError:
  undefined method `invalid' for #<ToyRobot::Simulator:...>
```

This method needs to take an argument which is the invalid command. It will then need to output a message telling us that the command is invalid. Let's add this `invalid` method to `ToyRobot::Simulator` now:

```ruby
def invalid(command)
  puts "'#{command.strip}' is an invalid command"
end
```

Running our tests again will show that it's all working:

```
55 examples, 0 failures
```

Great! Let's try running our application again:

```
 bundle exec exe/toy_robot commands.txt
'PLACE 1, 2, NORTH' is an invalid command
```

There we go! Our application is now correctly reporting invalid commands.

We've got one more thing left to check in our problem description now:

> All commands must be in upcase, all lower and mixed case commands will be ignored.

We can test this last bit out by having a `commands.txt` file that looks like this:

```
place 1,2,NORTH
Place 1,2,NORTH
PlAcE 1,2,NORTH
MoVe
RePort
InvaliD CommandS
```

All of these commands should be invalid. Let's run our application and see:

```
bundle exec exe/toy_robot commands.txt
'place 1,2,NORTH' is an invalid command
'Place 1,2,NORTH' is an invalid command
'PlAcE 1,2,NORTH' is an invalid command
'MoVe' is an invalid command
'RePort' is an invalid command
'InvaliD CommandS' is an invalid command
```

Yay! That was the last step! We've now verified the behaviour of our toy robot against the problem description.

## Conclusion

We've now finished building our toy robot application. Go and have a play around with it and kick the tyres. It's been a relatively long process, but we've reached the end now.

We have a framework for our robot in terms of both code and tests and so if we wanted to add more features to our robot like:

* A `MOVE 2` command which would move the robot two spaces instead of 1.
* A `UTURN` command which would turn a robot from facing `NORTH` to facing `SOUTH`.
* A `BEEP` command which would make the robot emit a "BEEP"

We could very easily add some tests for that functionality and then write it. As a bit of homework, try implementing the above list yourself.

Good luck!










